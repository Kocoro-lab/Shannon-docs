---
title: "实时流式传输"
description: "通过服务器发送事件和 WebSocket 监控任务执行"
---

## 概述

Shannon 提供实时事件流式传输，因此您可以在任务执行时进行监控。这对于以下场景至关重要：

- 向用户提供实时反馈
- 调试工作流执行
- 构建交互式 UI
- 监控长时间运行的任务

## 流式传输技术

Shannon 支持两种流式传输协议：

| 协议 | 用例 | 特性 |
|----------|----------|----------|
| **SSE**（服务器发送事件） | 单向服务器→客户端 | 简单、基于 HTTP、自动重连 |
| **WebSocket** | 双向 | 全双工、较低延迟 |

<Note>
由于 SSE 的简单性和内置重连处理，建议大多数用例使用 SSE。
</Note>

## 服务器发送事件（SSE）

### 使用 cURL

```bash
curl -N http://localhost:8080/api/v1/tasks/{task_id}/stream
```

输出：
```
event: AGENT_THINKING
data: {"message":"正在分析任务复杂度..."}

event: TASK_DECOMPOSED
data: {"subtasks":3,"strategy":"DAG"}

event: SUBTASK_STARTED
data: {"subtask_id":"1","query":"研究主题 A"}

event: AGENT_THINKING
data: {"message":"正在搜索信息..."}

event: TOOL_INVOKED
data: {"tool_name":"web_search","args":{"query":"主题 A"}}

event: TOOL_RESULT
data: {"tool_name":"web_search","result":"找到 5 个结果"}

event: SUBTASK_COMPLETED
data: {"subtask_id":"1","status":"COMPLETED"}

event: TASK_COMPLETED
data: {"result":"最终综合结果","metrics":{"latency_ms":5000}}
```

### 使用 Python SDK

```python
from shannon import ShannonClient

client = ShannonClient(http_endpoint="http://localhost:8080")

# 提交任务
handle = client.submit_task(
    query="研究 AI 趋势并创建摘要"
)

# 流式传输事件
for event in client.stream(handle.workflow_id):
    print(f"[{event.type}] {event.message}")

    if event.type == "TASK_COMPLETED":
        print(f"任务已完成：{event.message}")
        break
```

### 事件类型

| 事件类型 | 描述 | 数据字段 |
|------------|-------------|-------------|
| `AGENT_THINKING` | 智能体正在处理 | `message` |
| `TASK_DECOMPOSED` | 任务分解为子任务 | `subtasks`、`strategy` |
| `SUBTASK_STARTED` | 子任务执行开始 | `subtask_id`、`query` |
| `SUBTASK_COMPLETED` | 子任务完成 | `subtask_id`、`status`、`result` |
| `TOOL_INVOKED` | 工具执行开始 | `tool_name`、`args` |
| `TOOL_RESULT` | 工具返回结果 | `tool_name`、`result` |
| `AGENT_COMPLETED` | 智能体完成 | `agent_id`、`result` |
| `TASK_COMPLETED` | 整个任务完成 | `result`、`metrics` |
| `TASK_FAILED` | 任务遇到错误 | `error`、`error_code` |
| `BUDGET_WARNING` | 接近预算限制 | `used_tokens`、`max_tokens` |
| `BUDGET_EXCEEDED` | 达到预算限制 | `final_cost` |

## WebSocket 流式传输

### 通过 WebSocket 连接

```python
import asyncio
import websockets
import json

async def stream_task():
    uri = f"ws://localhost:8080/api/v1/stream/ws?workflow_id={workflow_id}"

    # 通过标头传递 API 密钥（网关需要基于标头的身份验证）
    async with websockets.connect(
        uri, extra_headers={'X-API-Key': 'sk_test_123456'}
    ) as websocket:
        while True:
            message = await websocket.recv()
            event = json.loads(message)
            print(f"事件：{event['type']}")

            if event['type'] == 'TASK_COMPLETED':
                break

asyncio.run(stream_task())
```

<Note>
WebSocket 流式传输目前仅支持服务器到客户端。使用 REST API `/api/v1/tasks/{id}/cancel` 取消任务。
</Note>

## 过滤事件

按类型过滤事件以减少噪音：

```python
# 仅显示重要事件
for event in client.stream(workflow_id):
    if event.type in ['TASK_DECOMPOSED', 'SUBTASK_COMPLETED', 'TASK_COMPLETED']:
        print(f"{event.type}：{event.message}")
```

## 进度跟踪

从事件计算任务进度：

```python
def track_progress(workflow_id):
    total_subtasks = 0
    completed_subtasks = 0

    for event in client.stream(workflow_id):
        if event.type == 'TASK_DECOMPOSED':
            # 跟踪分解已发生
            print(f"任务已分解：{event.message}")

        elif event.type == 'SUBTASK_COMPLETED':
            completed_subtasks += 1
            print(f"子任务 {completed_subtasks} 已完成")

        elif event.type == 'TASK_COMPLETED':
            print("✅ 任务完成！")
            break

track_progress(handle.workflow_id)
```

输出：
```
任务分为 3 部分
进度：33.3%
进度：66.7%
进度：100.0%
✅ 任务完成！
```

## 实时 UI 示例

### React 组件

```jsx
import { useEffect, useState } from 'react';

function TaskMonitor({ taskId }) {
  const [events, setEvents] = useState([]);
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    const eventSource = new EventSource(
      `http://localhost:8080/api/v1/tasks/${taskId}/stream`
    );

    eventSource.onmessage = (e) => {
      const event = JSON.parse(e.data);
      setEvents(prev => [...prev, event]);

      // 更新进度
      if (event.type === 'SUBTASK_COMPLETED') {
        setProgress(prev => prev + (100 / event.totalSubtasks));
      }
    };

    return () => eventSource.close();
  }, [taskId]);

  return (
    <div>
      <progress value={progress} max={100} />
      <ul>
        {events.map((e, i) => (
          <li key={i}>[{e.type}] {e.message}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 错误处理

优雅地处理连接失败：

```python
from shannon import ShannonClient
from shannon.errors import StreamingError
import time

def robust_streaming(workflow_id, max_retries=3):
    client = ShannonClient(http_endpoint="http://localhost:8080")

    for attempt in range(max_retries):
        try:
            for event in client.stream(workflow_id):
                print(f"事件：{event.type}")

                if event.type == 'TASK_COMPLETED':
                    # 获取最终状态以检索结果
                    status = client.get_status(workflow_id.replace('wf-', 'task-'))
                    return status.result

        except StreamingError as e:
            print(f"流错误（尝试 {attempt + 1}）：{e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # 指数退避
            else:
                raise
```

## 流式传输身份验证

启用身份验证时，提供 API 密钥：

### 带 API 密钥的 SSE

```bash
curl -N \
  -H "X-API-Key: sk_test_123456" \
  http://localhost:8080/api/v1/tasks/{task_id}/stream
```

### 带 API 密钥的 Python SDK

```python
client = ShannonClient(
    http_endpoint="http://localhost:8080",
    api_key="sk_test_123456"
)

# API 密钥自动包含在所有请求中
for event in client.stream(workflow_id):
    print(event)
```

## 性能考虑

### 事件缓冲

Shannon 缓冲事件以防止压垮客户端：

```yaml
# config/shannon.yaml
streaming:
  buffer_size: 100  # 最大排队事件数
  flush_interval_ms: 100  # 每 100 毫秒发送批次
```

### 保持连接

SSE 每 15 秒发送保持连接注释以防止超时：

```
: keepalive
: keepalive
event: AGENT_THINKING
data: {"message":"..."}
```

### 资源清理

完成后始终关闭流：

```python
# 遍历事件（自动处理连接）
for event in client.stream(workflow_id):
    if event.type == 'TASK_COMPLETED':
        break
# 无需显式关闭
```

## 多任务监控

同时监控多个任务：

```python
import asyncio

async def monitor_task(client, workflow_id):
    # 在异步上下文中使用同步 stream()
    for event in client.stream(workflow_id):
        print(f"[{workflow_id}] {event.type}")
        if event.type == 'TASK_COMPLETED':
            # 从状态获取最终结果
            task_id = workflow_id.replace('wf-', 'task-')
            status = client.get_status(task_id)
            return status.result

async def monitor_all(task_ids):
    client = AsyncShannonClient(http_endpoint="http://localhost:8080")

    # 并行监控所有任务
    results = await asyncio.gather(*[
        monitor_task(client, tid) for tid in task_ids
    ])

    return results

# 运行
task_ids = ["task-1", "task-2", "task-3"]
results = asyncio.run(monitor_all(task_ids))
```

## 仪表板集成

Shannon 的内置仪表板（http://localhost:2111）使用 SSE 进行实时更新：

- 活动任务的实时事件源
- 实时指标更新
- 智能体状态可视化
- 令牌使用图表

## 最佳实践

### 1. 使用 SSE 进行简单监控

```python
# ✅ 好：简单的 SSE 流式传输
for event in client.stream(workflow_id):
    print(event.type)
```

### 2. 处理断开连接

```python
# ✅ 好：重试逻辑
for attempt in range(3):
    try:
        for event in client.stream(workflow_id):
            process_event(event)
        break
    except StreamingError:
        if attempt == 2:
            raise
        time.sleep(2)
```

### 3. 过滤不必要的事件

```python
# ✅ 好：仅关键事件
critical_events = ['TASK_DECOMPOSED', 'TASK_COMPLETED', 'TASK_FAILED']
for event in client.stream(workflow_id):
    if event.type in critical_events:
        handle_event(event)
```

### 4. 设置超时

```python
# ✅ 好：超时保护
import signal

def timeout_handler(signum, frame):
    raise TimeoutError("流超时")

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(300)  # 5 分钟超时

try:
    for event in client.stream(workflow_id):
        print(event)
finally:
    signal.alarm(0)  # 取消警报
```

## 下一步

<CardGroup cols={2}>
  <Card title="Python SDK" icon="python" href="/cn/sdk/python/streaming">
    使用 SDK 进行异步流式传输
  </Card>
  <Card title="API 参考" icon="code" href="/cn/api/endpoints/stream-task">
    流式传输 API 详情
  </Card>
  <Card title="监控" icon="chart-line" href="/cn/quickstart/concepts/monitoring">
    任务监控指南
  </Card>
  <Card title="WebSocket API" icon="plug" href="/cn/api/overview">
    WebSocket 文档
  </Card>
</CardGroup>


---

## 参与翻译

如果您想帮助翻译此文档，请访问我们的 [GitHub 仓库](https://github.com/Kocoro-lab/Shannon)。
