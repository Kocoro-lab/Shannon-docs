---
title: "Swarm 多智能体协作"
description: "了解 Shannon 的 Swarm 工作流：持久化、自主的多智能体协作"
---

## 什么是 Swarm 模式？

Swarm 模式部署多个持久化的自主智能体，它们并行工作以解决复杂任务。与标准 DAG 或 Supervisor 工作流中智能体只执行一次并返回结果不同，Swarm 智能体运行迭代式**推理-行动循环**——检查消息邮箱、调用工具、与队友分享发现，并独立收敛。

Swarm 监督者监控执行过程，并在智能体请求帮助时动态生成辅助智能体。

## 工作原理

Shannon 的 Swarm 工作流遵循四阶段生命周期：

### 阶段 1：任务分解

监督者接收查询并将其分解为子任务，使用与其他工作流相同的分解引擎。每个子任务成为一个智能体的任务。

```
查询: "对比美国、日本和韩国的 AI 芯片市场"

子任务:
├── 智能体 1: "研究美国 AI 芯片市场格局"
├── 智能体 2: "研究日本 AI 芯片市场格局"
└── 智能体 3: "研究韩国 AI 芯片市场格局"
```

### 阶段 2：智能体生成

对于每个子任务，监督者生成一个 **AgentLoop** 子工作流。每个智能体接收：

- 唯一名称（确定性的，基于日本车站名称）
- 其子任务描述
- **团队名册**，列出所有智能体及其任务
- 共享工作区的访问权限

### 阶段 3：并行执行

所有智能体同时工作。每个智能体运行最多 25 次迭代（可配置）的推理-行动循环：

1. **检查邮箱**，查看来自其他智能体的消息
2. **读取共享工作区**，获取队友发布的发现
3. **调用 LLM** 决定下一步行动
4. **执行行动**（工具调用、发布数据、发送消息、请求帮助或完成）
5. **检查收敛**（智能体是否陷入循环或已完成？）

### 阶段 4：综合

当所有智能体完成后，监督者收集结果并生成统一的响应。如果只有一个智能体结果，直接返回。对于多个结果，LLM 综合步骤将各智能体的发现合并为连贯的答案。

## 智能体行动

每次迭代，智能体选择一个行动：

| 行动 | 描述 |
|------|------|
| `tool_call` | 执行工具（网页搜索、文件读取等） |
| `publish_data` | 通过工作区与团队分享发现 |
| `send_message` | 向特定队友发送直接消息 |
| `request_help` | 请求监督者生成新的辅助智能体 |
| `done` | 返回最终响应并退出 |

## 智能体间通信

Swarm 智能体通过两种机制协作：

### P2P 消息

智能体通过 Redis 支持的邮箱向特定队友发送直接消息。消息类型包括 `request`、`offer`、`accept`、`delegation` 和 `info`。

每次 LLM 调用前，智能体的邮箱会被检查是否有新消息。传入的消息会出现在智能体的提示上下文中。

### 共享工作区

智能体将发现发布到基于主题的工作区列表中。每次迭代前，每个智能体都会从所有主题获取最近的工作区条目，使整个团队了解集体进展。

```
共享工作区:
├── 主题: "findings"
│   ├── Agent-Takao: "NVIDIA 以 80% 的市场份额主导美国市场..."
│   └── Agent-Mitaka: "日本专注于边缘 AI 芯片..."
└── 主题: "sources"
    └── Agent-Kichijoji: "三星晶圆代工计划已公布..."
```

## 动态智能体生成

当智能体遇到无法独立处理的子任务时，可以向监督者请求帮助：

1. 智能体发送 `request_help` 行动，包含描述和所需技能
2. 监督者通过邮箱接收请求（每 3 秒轮询一次）
3. 监督者生成新的 AgentLoop 处理辅助任务
4. 监督者通知请求智能体新智能体的 ID

**安全限制**：每个智能体最多生成一个辅助者，总智能体数受配置的最大值限制（默认：10）。

## 收敛检测

三种机制防止智能体无限运行：

<AccordionGroup>
  <Accordion title="无进展检测">
    如果智能体连续 3 次迭代没有使用任何工具（仅消息传递或发布），则认为已收敛，返回部分发现。
  </Accordion>

  <Accordion title="连续错误中止">
    如果连续发生 3 次永久性工具错误（非速率限制等瞬时错误），智能体中止并报告失败。
  </Accordion>

  <Accordion title="最大迭代强制完成">
    在最后一次迭代时，如果智能体尚未调用 `done`，工作流强制完成并从最近的迭代中构建摘要。
  </Accordion>
</AccordionGroup>

瞬时错误（速率限制、超时、503）触发自动重试，退避时间递增（5 秒增量，最大 30 秒），不计入中止阈值。

## 何时使用 Swarm

| 场景 | 推荐工作流 |
|------|-----------|
| 简单问答、单步任务 | Simple / DAG |
| 带引用的多步骤研究 | Research Workflow |
| 需要智能体实时协作的任务 | **Swarm** |
| 智能体需要分享中间发现的任务 | **Swarm** |
| 需要动态发现子任务的长时间探索 | **Swarm** |
| 需要工具迭代（搜索、分析、优化）的任务 | **Swarm** |

<Note>
Swarm 模式比标准工作流使用更多 Token，因为每个智能体运行多次 LLM 迭代。请在真正受益于持久化协作多智能体执行的任务中使用它。
</Note>

## 配置

Swarm 行为通过 `config/features.yaml` 控制：

| 参数 | 默认值 | 描述 |
|------|--------|------|
| `swarm.enabled` | `true` | 启用/禁用 Swarm 工作流 |
| `swarm.max_agents` | `10` | 最大智能体总数（初始 + 动态） |
| `swarm.max_iterations_per_agent` | `25` | 每个智能体的最大推理-行动循环次数 |
| `swarm.agent_timeout_seconds` | `600` | 每个智能体超时（10 分钟） |
| `swarm.max_messages_per_agent` | `20` | 每个智能体的 P2P 消息上限 |
| `swarm.workspace_snippet_chars` | `800` | 提示中每个工作区条目的最大字符数 |
| `swarm.workspace_max_entries` | `5` | 向每个智能体显示的最近条目数 |

## 流式事件

Swarm 工作流发出 SSE 事件用于实时监控：

| 事件类型 | Agent ID | 触发时机 |
|---------|----------|---------|
| `WORKFLOW_STARTED` | `swarm-supervisor` | 工作流开始 |
| `PROGRESS` | `swarm-supervisor` | 规划、生成、监控、综合 |
| `AGENT_STARTED` | 智能体名称 | 智能体开始第一次迭代 |
| `AGENT_COMPLETED` | 智能体名称 | 智能体完成 |
| `WORKFLOW_COMPLETED` | `swarm-supervisor` | 最终综合完成 |

## 下一步

<CardGroup cols={2}>
  <Card title="Swarm 教程" icon="users" href="/cn/tutorials/swarm-workflow">
    分步指南：运行 Swarm 工作流
  </Card>
  <Card title="工作流和模式" icon="diagram-project" href="/cn/quickstart/concepts/workflows">
    其他工作流类型和认知模式
  </Card>
  <Card title="流式传输" icon="stream" href="/cn/quickstart/concepts/streaming">
    实时事件流
  </Card>
  <Card title="成本控制" icon="dollar-sign" href="/cn/quickstart/concepts/cost-control">
    多智能体任务的预算管理
  </Card>
</CardGroup>
