---
title: "错误处理"
description: "在 Shannon Python SDK 中优雅地处理错误"
---

<Note>
正在扩展错误处理文档。下面显示了核心模式。
</Note>

## 概述

Shannon Python SDK 提供全面的错误处理以帮助您构建强大的应用程序。所有 SDK 异常都继承自 `ShannonError`。

## 异常层次结构

```python
ShannonError                    # 基础异常
├── ConnectionError             # 网络/连接问题
├── AuthenticationError         # API 密钥/身份验证问题
├── ValidationError            # 无效参数
├── TaskNotFoundError          # 任务不存在
├── SessionNotFoundError       # 会话不存在
├── TaskTimeoutError           # 任务超出超时
└── ConnectionError            # 包括 HTTP 429 速率限制
```

<Note>
预算和任务失败处理：预算超出和任务失败不是异常。失败请检查 `status.status`。令牌用量与成本合计请通过 `list_tasks()` 读取任务列表中的 `total_token_usage`。
</Note>

## 基本错误处理

### Try-Catch 模式

```python
from shannon import ShannonClient, ShannonError

client = ShannonClient(base_url="http://localhost:8080")

try:
    handle = client.submit_task(
        query="分析此数据",
        # 模式自动选择
    )
    status = client.wait(handle.task_id)

except ConnectionError:
    print("无法连接到 Shannon 服务器")
except AuthenticationError:
    print("无效的 API 凭证")
except TaskTimeoutError:
    print("任务超出超时限制")
except ShannonError as e:
    print(f"Shannon 错误：{e}")

# 检查预算/失败状态
status = client.get_status(handle.task_id)
from shannon import TaskStatusEnum
if status.status == TaskStatusEnum.FAILED:
    print(f"任务失败：{status.error_message}")
except Exception as e:
    print(f"意外错误：{e}")
```

## 特定错误类型

### 连接错误

处理网络和连接问题：

```python
import time
from shannon import ShannonClient, ConnectionError

def connect_with_retry(max_retries=3):
    client = ShannonClient()

    for attempt in range(max_retries):
        try:
            # 使用简单任务测试连接
            handle = client.submit_task(query="ping")
            return client

        except ConnectionError as e:
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # 指数退避
                print(f"连接失败，{wait_time}s 后重试...")
                time.sleep(wait_time)
            else:
                print(f"{max_retries} 次尝试后无法连接")
                raise
```

### 成本与失败检查

通过状态判断失败，并使用 `list_tasks()` 获取用量与成本合计：

```python
from shannon import ShannonClient, TaskStatusEnum

client = ShannonClient()
handle = client.submit_task(query="Analyze data")
status = client.wait(handle.task_id)

# 失败检查
if status.status == TaskStatusEnum.FAILED:
    print(f"失败：{status.error_message}")

# 用量与成本（从任务列表读取）
tasks, _ = client.list_tasks(limit=50)
usage = next((t.total_token_usage for t in tasks if t.task_id == handle.task_id), None)
if usage:
    print(f"tokens={usage.total_tokens} prompt={usage.prompt_tokens} completion={usage.completion_tokens} cost=${usage.cost_usd:.6f}")
```

### 超时错误

处理长时间运行的操作：

```python
from shannon import ShannonClient, TimeoutError
import asyncio

async def with_timeout_handling():
    async with AsyncShannonClient() as client:
        try:
            handle = await asyncio.wait_for(
                client.submit_task(query="复杂分析"),
                timeout=10.0,
            )
            result = await asyncio.wait_for(client.wait(handle.task_id), timeout=60.0)
            return result

        except asyncio.TimeoutError:
            print("操作超时")
            return None
```

### 速率限制

优雅地处理 API 速率限制：

```python
from shannon import ShannonClient
import time

def handle_rate_limits(queries):
    client = ShannonClient()
    results = []

    for query in queries:
        while True:
            try:
                handle = client.submit_task(query=query)
                result = client.wait(handle.task_id)
                results.append(result)
                break  # 成功，移到下一个

            except ConnectionError:
                # 等待速率限制重置
        # 指数退避等待
        time.sleep(1)

    return results
```

## 验证错误

处理无效参数：

```python
from shannon import ShannonClient, ValidationError

def validate_and_submit(query, session_id=None):
    client = ShannonClient()

    try:
        return client.submit_task(query=query, session_id=session_id)
    except ValidationError as e:
        print(f"无效参数：{e}")
        return None
```

## 任务失败处理

处理任务执行失败：

```python
from shannon import ShannonClient

def handle_task_failure(query):
    client = ShannonClient()

    try:
        handle = client.submit_task(query=query)
        status = client.wait(handle.task_id, timeout=120)
        return status
    except TaskTimeoutError:
        print("任务超时；请考虑增加超时或简化请求。")
        return None
```

## 记录错误

实现全面的错误日志：

```python
import logging
from shannon import ShannonClient, ShannonError

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('shannon')

def logged_task_submission(query):
    client = ShannonClient()

    try:
        logger.info(f"提交任务：{query[:50]}...")
        handle = client.submit_task(query=query)

        logger.info(f"任务已提交：task_id={handle.task_id}")
        result = client.wait(handle.task_id)

        logger.info("任务成功完成")
        return result.result

    except ShannonError as e:
        logger.error(f"Shannon 错误：{e}", exc_info=True)
        raise

    except Exception as e:
        logger.critical(f"意外错误：{e}", exc_info=True)
        raise
```

## 断路器模式

为弹性实现断路器：

```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, reset_timeout=60):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.reset_timeout = reset_timeout
        self.last_failure_time = None
        self.state = "closed"  # closed, open, half-open

    def call(self, func, *args, **kwargs):
        if self.state == "open":
            if time.time() - self.last_failure_time > self.reset_timeout:
                self.state = "half-open"
            else:
                raise Exception("断路器是打开的")

        try:
            result = func(*args, **kwargs)
            if self.state == "half-open":
                self.state = "closed"
                self.failure_count = 0
            return result

        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()

            if self.failure_count >= self.failure_threshold:
                self.state = "open"

            raise

# 用法
breaker = CircuitBreaker()
client = ShannonClient()

try:
    result = breaker.call(
        client.submit_task,
        query="分析数据"
    )
except Exception as e:
    print(f"服务不可用：{e}")
```

## 最佳实践

1. **始终在泛型异常之前捕获特定异常**
2. **使用指数退避实现重试逻辑**
3. **记录错误**以供调试和监控
4. **为关键操作提供回退选项**
5. **设置合理的超时**以避免挂起
6. **在提交前验证输入**
7. **对外部依赖项使用断路器**

## 后续步骤

<CardGroup cols={2}>
  <Card title="示例" icon="code" href="/cn/sdk/python/examples">
    查看错误处理的实际应用
  </Card>
  <Card title="异步用法" icon="bolt" href="/cn/sdk/python/async-usage">
    异步错误模式
  </Card>
</CardGroup>
