---
title: "错误处理"
description: "在 Shannon Python SDK 中优雅地处理错误"
---

<Note>
正在扩展错误处理文档。下面显示了核心模式。
</Note>

## 概述

Shannon Python SDK 提供全面的错误处理以帮助您构建强大的应用程序。所有 SDK 异常都继承自 `ShannonError`。

## 异常层次结构

```python
ShannonError                    # 基础异常
├── ConnectionError             # 网络/连接问题
├── AuthenticationError         # API 密钥/身份验证问题
├── ValidationError            # 无效参数
├── TaskNotFoundError          # 任务不存在
├── SessionNotFoundError       # 会话不存在
├── TaskTimeoutError           # 任务超出超时
└── ConnectionError            # 包括 HTTP 429 速率限制
```

<Note>
**预算和任务失败处理**：预算超出和任务失败不是异常。检查 `status.status` 字段是否为 `TASK_STATUS_FAILED` 或通过 `status.metrics.cost_usd` 监控成本。
</Note>

## 基本错误处理

### Try-Catch 模式

```python
from shannon import ShannonClient, ShannonError

client = ShannonClient(http_endpoint="http://localhost:8080")

try:
    handle = client.submit_task(
        query="分析此数据",
        # 模式自动选择
    )
    result = client.get_status(handle.workflow_id)

except ConnectionError:
    print("无法连接到 Shannon 服务器")
except AuthenticationError:
    print("无效的 API 凭证")
except TaskTimeoutError:
    print("任务超出超时限制")
except ShannonError as e:
    print(f"Shannon 错误：{e}")

# 检查预算/失败状态
status = client.get_status(handle.task_id)
if status.status == "TASK_STATUS_FAILED":
    print(f"任务失败：{status.error}")
if status.metrics and status.metrics.cost_usd > 1.0:
    print(f"高成本：${status.metrics.cost_usd}")
except Exception as e:
    print(f"意外错误：{e}")
```

## 特定错误类型

### 连接错误

处理网络和连接问题：

```python
import time
from shannon import ShannonClient, ConnectionError

def connect_with_retry(max_retries=3):
    client = ShannonClient()

    for attempt in range(max_retries):
        try:
            # 使用简单任务测试连接
            handle = client.submit_task(query="ping")
            return client

        except ConnectionError as e:
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # 指数退避
                print(f"连接失败，{wait_time}s 后重试...")
                time.sleep(wait_time)
            else:
                print(f"{max_retries} 次尝试后无法连接")
                raise
```

### 预算错误

处理成本限制超出：

```python
from shannon import ShannonClient

def submit_with_fallback(query):
    client = ShannonClient()

    try:
        # 尝试高级模式
        handle = client.submit_task(
            query=query,
            # 模式自动选择,
            config={"budget": {"max_cost_usd": 1.0}}
        )

    except ValidationError:
        print("预算超出，回退到简单模式")

        # 回退到更简单、更便宜的模式
        handle = client.submit_task(
            query=query,
            # 模式自动选择,
            config={"budget": {"max_cost_usd": 0.10}}
        )

    return client.get_status(handle.workflow_id)
```

### 超时错误

处理长时间运行的操作：

```python
from shannon import ShannonClient, TimeoutError
import asyncio

async def with_timeout_handling():
    client = AsyncShannonClient()

    try:
        # 设置积极的超时
        result = await asyncio.wait_for(
            client.submit_and_wait(query="复杂分析"),
            timeout=60.0
        )

    except TimeoutError:
        print("操作在 60 秒后超时")
        # 可能会使用更简单的查询或更长的超时重试
        return None

    except asyncio.TimeoutError:
        print("达到 Asyncio 超时")
        return None

    return result
```

### 速率限制

优雅地处理 API 速率限制：

```python
from shannon import ShannonClient
import time

def handle_rate_limits(queries):
    client = ShannonClient()
    results = []

    for query in queries:
        while True:
            try:
                handle = client.submit_task(query=query)
                result = client.get_status(handle.workflow_id)
                results.append(result)
                break  # 成功，移到下一个

            except ConnectionError:
                # 等待速率限制重置
                reset_time = e.reset_after
                print(f"速率限制，等待 {reset_time}s")
                time.sleep(reset_time)

    return results
```

## 验证错误

处理无效参数：

```python
from shannon import ShannonClient, ValidationError

def validate_and_submit(query, session_id=None):
    client = ShannonClient()

    try:
        handle = client.submit_task(
            query=query,
            session_id=session_id
        )

    except ValidationError as e:
        print(f"无效参数：{e}")

        # 使用最少参数重试
        handle = client.submit_task(
            query=query
            # Shannon 自动选择模式
            )
        elif "query" in str(e):
            print("查询不能为空")
            return None
        else:
            raise

    return handle
```

## 任务失败处理

处理任务执行失败：

```python
from shannon import ShannonClient

def handle_task_failure(query):
    client = ShannonClient()

    try:
        handle = client.submit_task(query=query, # 模式自动选择)
        result = client.get_status(handle.workflow_id)

    except TaskTimeoutError:
        print(f"任务失败：{e.reason}")

        # 检查失败原因
        if e.reason == "INSUFFICIENT_CONTEXT":
            # 使用更多上下文重试
            handle = client.submit_task(
                query=f"{query}。请做出合理的假设。",
                # 模式自动选择
            )
        elif e.reason == "TOOL_ERROR":
            # 在不使用工具的情况下重试
            handle = client.submit_task(
                query=query,
                # 模式自动选择
            )
        else:
            # 记录并重新抛出
            print(f"无法恢复的错误：{e}")
            raise

    return client.get_status(handle.workflow_id)
```

## 记录错误

实现全面的错误日志：

```python
import logging
from shannon import ShannonClient, ShannonError

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('shannon')

def logged_task_submission(query):
    client = ShannonClient()

    try:
        logger.info(f"提交任务：{query[:50]}...")
        handle = client.submit_task(query=query)

        logger.info(f"任务已提交：{handle.workflow_id}")
        result = client.get_status(handle.workflow_id)

        logger.info("任务成功完成")
        return result

    except ShannonError as e:
        logger.error(f"Shannon 错误：{e}", exc_info=True)
        raise

    except Exception as e:
        logger.critical(f"意外错误：{e}", exc_info=True)
        raise
```

## 断路器模式

为弹性实现断路器：

```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, reset_timeout=60):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.reset_timeout = reset_timeout
        self.last_failure_time = None
        self.state = "closed"  # closed, open, half-open

    def call(self, func, *args, **kwargs):
        if self.state == "open":
            if time.time() - self.last_failure_time > self.reset_timeout:
                self.state = "half-open"
            else:
                raise Exception("断路器是打开的")

        try:
            result = func(*args, **kwargs)
            if self.state == "half-open":
                self.state = "closed"
                self.failure_count = 0
            return result

        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()

            if self.failure_count >= self.failure_threshold:
                self.state = "open"

            raise

# 用法
breaker = CircuitBreaker()
client = ShannonClient()

try:
    result = breaker.call(
        client.submit_task,
        query="分析数据"
    )
except Exception as e:
    print(f"服务不可用：{e}")
```

## 最佳实践

1. **始终在泛型异常之前捕获特定异常**
2. **使用指数退避实现重试逻辑**
3. **记录错误**以供调试和监控
4. **为关键操作提供回退选项**
5. **设置合理的超时**以避免挂起
6. **在提交前验证输入**
7. **对外部依赖项使用断路器**

## 后续步骤

<CardGroup cols={2}>
  <Card title="示例" icon="code" href="/cn/sdk/python/examples">
    查看错误处理的实际应用
  </Card>
  <Card title="异步用法" icon="bolt" href="/cn/sdk/python/async-usage">
    异步错误模式
  </Card>
</CardGroup>
