---
title: "获取任务状态"
description: "GET /api/v1/tasks/{id} - 检索任务状态"
---

## 端点

```
GET /api/v1/tasks/{task_id}
```

检索任务的当前状态。

## 请求

### 路径参数

| 参数 | 类型 | 必需 | 描述 |
|-----------|------|----------|-------------|
| `task_id` | string | 是 | 来自提交响应的任务标识符 |

### 请求头

| 请求头 | 必需 | 描述 |
|--------|----------|-------------|
| `X-API-Key` | 条件性 | API 密钥（启用认证时） |

## 响应

### 成功 (200 OK)

<CodeGroup>

```json 运行中的任务
{
  "task_id": "task-dev-1730000000",
  "status": "TASK_STATUS_RUNNING",
  "response": null,
  "error": "",
  "query": "分析此文本的情感",
  "session_id": "sess-123",
  "mode": "EXECUTION_MODE_STANDARD",
  "created_at": "2024-10-22T10:30:00Z",
  "updated_at": "2024-10-22T10:30:15Z"
}
```

```json 已完成的任务
{
  "task_id": "task-dev-1730000000",
  "status": "TASK_STATUS_COMPLETED",
  "response": {
    "result": "情感非常积极..."
  },
  "error": "",
  "query": "分析此文本的情感",
  "session_id": "sess-123",
  "mode": "EXECUTION_MODE_STANDARD",
  "created_at": "2024-10-22T10:30:00Z",
  "updated_at": "2024-10-22T10:30:25Z"
}
```

```json 失败的任务
{
  "task_id": "task-dev-1730000000",
  "status": "TASK_STATUS_FAILED",
  "response": null,
  "error": "预算超限",
  "query": "分析此文本的情感",
  "session_id": "sess-123",
  "mode": "EXECUTION_MODE_STANDARD",
  "created_at": "2024-10-22T10:30:00Z",
  "updated_at": "2024-10-22T10:30:12Z"
}
```

</CodeGroup>

### 错误响应

| 状态码 | 错误代码 | 描述 |
|--------|------------|-------------|
| 404 | `TASK_NOT_FOUND` | 任务 ID 不存在 |
| 401 | `UNAUTHORIZED` | 无效或缺少 API 密钥 |

## 示例

### 基本状态检查

<CodeGroup>

```bash cURL
curl http://localhost:8080/api/v1/tasks/task-dev-1730000000
```

```python Python SDK
from shannon import ShannonClient

client = ShannonClient()

status = client.get_status("task-dev-1730000000")
print("状态:", status.status)
if status.status == status.status.COMPLETED:
    print("结果:", status.result)
```

```javascript JavaScript (fetch)
const response = await fetch('http://localhost:8080/api/v1/tasks/task-dev-1730000000');
const task = await response.json();
console.log('状态:', task.status);
if (task.status === 'TASK_STATUS_COMPLETED') {
  console.log('响应:', task.response);
}
```

</CodeGroup>

### 轮询直到完成

<CodeGroup>

```python Python SDK
import time

handle = client.submit_task(query="分析数据")

while True:
    status = client.get_status(handle.task_id)
    print("状态:", status.status)
    if status.status in [status.status.COMPLETED, status.status.FAILED]:
        break
    time.sleep(2)

if status.status == status.status.COMPLETED:
    print("结果:", status.result)
else:
    print("错误:", status.error_message)
```

```bash Shell 脚本
#!/bin/bash

TASK_ID="task-dev-1730000000"

while true; do
  STATUS=$(curl -s http://localhost:8080/api/v1/tasks/$TASK_ID | jq -r '.status')

  echo "状态: $STATUS"

  if [ "$STATUS" = "COMPLETED" ] || [ "$STATUS" = "FAILED" ]; then
    break
  fi

  sleep 2
done

# 获取最终响应载荷
curl http://localhost:8080/api/v1/tasks/$TASK_ID | jq '.response'
```

</CodeGroup>

### 等待完成 (SDK)

```python
handle = client.submit_task(query="复杂分析")
final = client.wait(handle.task_id, timeout=300)
print("结果:", final.result)
```

## 响应字段

### 任务状态

| 字段 | 类型 | 描述 |
|-------|------|-------------|
| `task_id` | string | 唯一任务标识符 |
| `status` | string | `TASK_STATUS_*` |
| `response` | object\|null | 结果 JSON（完成时） |
| `error` | string | 错误消息（失败时） |
| `query` | string | 原始查询文本 |
| `session_id` | string | 会话 ID |
| `mode` | string | 执行模式（枚举字符串） |

<Note>
REST 状态响应不包含详细指标。使用仪表板、流式事件或 gRPC API/SDK 获取指标。
</Note>

## 任务状态值

| 状态 | 描述 |
|--------|-------------|
| `QUEUED` | 任务等待执行 |
| `RUNNING` | 任务正在执行 |
| `COMPLETED` | 任务成功完成 |
| `FAILED` | 任务遇到错误 |
| `CANCELLED` | 任务被用户取消 |

## 进度跟踪

进度基于子任务完成情况计算：

```python
progress = completed_subtasks / total_subtasks
```

对于简单模式（无分解）：
- `0.0` - 未开始
- `0.5` - 进行中
- `1.0` - 完成

## 最佳实践

### 1. 使用 SDK 的 wait 辅助方法

```python
# ✅ 好：SDK 处理轮询
result = client.wait(handle.task_id, timeout=300)

# ❌ 避免：手动轮询
while True:
    status = client.get_status(task_id)
    if status.status == "COMPLETED":
        break
    time.sleep(1)
```

### 2. 检查错误

```python
status = client.get_status(task_id)

if status.status == "FAILED":
    print(f"错误: {status.error.code}")
    print(f"消息: {status.error.message}")

    if status.error.code == "BUDGET_EXCEEDED":
        print("增加预算或简化任务")
```

### 3. 监控 Token 使用

```python
if status.status == "COMPLETED":
    tokens = status.metrics.token_usage.total_tokens
    cost = status.metrics.token_usage.cost_usd

    if cost > 1.0:
        print(f"警告: 高成本 (${cost:.2f})")
```

### 4. 对长任务使用流式传输

对于耗时超过 30 秒的任务，使用流式传输而不是轮询：

```python
# 而不是轮询
for event in client.stream(workflow_id):
    if event.type == "TASK_COMPLETED":
        break
```

## 常见错误代码

| 错误代码 | 描述 | 解决方案 |
|------------|-------------|----------|
| `BUDGET_EXCEEDED` | 达到 token/成本限制 | 增加预算或简化任务 |
| `TIMEOUT` | 执行超时 | 增加 timeout_seconds |
| `LLM_ERROR` | LLM 提供商错误 | 检查 API 密钥，重试 |
| `POLICY_VIOLATION` | OPA 策略拒绝 | 检查权限 |
| `INVALID_STATE` | 任务处于无效状态 | 检查任务状态 |

## 下一步

<CardGroup cols={2}>
  <Card title="流式传输事件" icon="stream" href="/cn/api/endpoints/stream-task">
    实时监控任务
  </Card>
  <Card title="取消任务" icon="xmark" href="/cn/api/endpoints/cancel-task">
    取消（通过 SDK / gRPC）
  </Card>
  <Card title="Python SDK" icon="python" href="/cn/sdk/python/quickstart">
    SDK 使用
  </Card>
  <Card title="API 概述" icon="code" href="/cn/api/overview">
    端点和使用
  </Card>
</CardGroup>
