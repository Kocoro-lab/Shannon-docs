---
title: "POST /api/v1/tasks"
description: "提交新任务以供执行"
---

## 端点

```
POST http://localhost:8080/api/v1/tasks
```

## 描述

将新任务提交给 Shannon 以供执行。任务立即排队，由 Temporal 工作流引擎异步处理。

## 身份验证

**必需**：是

在请求头中包含 API 密钥：
```
X-API-Key: sk_test_123456
```

## 请求

### 请求头

| 请求头 | 必需 | 描述 | 示例 |
|-------|------|------|------|
| `X-API-Key` | 是 | 身份验证密钥 | `sk_test_123456` |
| `Content-Type` | 是 | 必须是 `application/json` | `application/json` |
| `Idempotency-Key` | 否 | 幂等性的唯一密钥 | `550e8400-e29b-41d4-a716-446655440000` |
| `traceparent` | 否 | W3C 追踪上下文 | `00-4bf92f...` |

### 请求体参数

| 参数 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `query` | string | 是 | 自然语言任务描述 |
| `session_id` | string | 否 | 多轮对话的会话标识符 |
| `context` | object | 否 | 作为键值对的附加上下文数据 |
| `mode` | string | 否 | 执行模式：`simple` 或 `supervisor` |
| `model_tier` | string | 否 | 模型层级：`small`、`medium`、`large` |

### 请求体架构

```json
{
  "query": "string (必需)",
  "session_id": "string (可选)",
  "mode": "simple | supervisor (可选)",
  "model_tier": "small | medium | large (可选)",
  "context": {
    "role": "analysis",
    "system_prompt": "你是一个简洁的助手。",
    "prompt_params": {"profile_id": "49598h6e", "current_date": "2025-10-25"},
    "model_tier": "large",
    "model_override": "gpt-4.1",
    "template": "research_summary",
    "template_version": "1.0.0",
    "template_name": "research_summary",
    "disable_ai": true,
    "history_window_size": 75,
    "primers_count": 3,
    "recents_count": 20,
    "compression_trigger_ratio": 0.75,
    "compression_target_ratio": 0.375
  }
}
```

### 上下文参数 (`context.*`)

支持的键：

- `role` — 角色预设（如 `analysis`、`research`、`writer`）
- `system_prompt` — 覆盖角色提示；支持从 `prompt_params` 引用 `${var}`
- `prompt_params` — 提示/工具的自定义参数
- `model_tier` — 当顶层未提供时作为回退
- `model_override` — 指定具体模型（如 `gpt-4.1`）
- `template` — 模板名称（别名：`template_name`）
- `template_version` — 模板版本
- `disable_ai` — 仅模板模式（不回退到 AI）
- 窗口控制：`history_window_size`、`use_case_preset`、`primers_count`、`recents_count`、`compression_trigger_ratio`、`compression_target_ratio`

规则：
- 顶层 `model_tier` 优先于 `context.model_tier`。
- `mode` 仅支持 `simple|supervisor`。
- `model_tier` 仅支持 `small|medium|large`。

## 响应

### 成功响应

**状态**：`200 OK`

**响应头**：
- `X-Workflow-ID`：Temporal 工作流标识符
- `X-Session-ID`：会话标识符（如果未提供则自动生成）

**响应体**：
```json
{
  "task_id": "string",
  "status": "string",
  "message": "string (可选)",
  "created_at": "timestamp"
}
```

### 响应字段

| 字段 | 类型 | 描述 |
|------|------|------|
| `task_id` | string | 唯一任务标识符（也是工作流 ID） |
| `status` | string | 初始任务状态（通常是 `TASK_STATUS_QUEUED`） |
| `message` | string | 可选的状态消息 |
| `created_at` | timestamp | 任务创建时间（ISO 8601） |

### 状态值

- `TASK_STATUS_UNSPECIFIED` - 状态未知
- `TASK_STATUS_QUEUED` - 任务已排队等待执行
- `TASK_STATUS_RUNNING` - 任务正在执行
- `TASK_STATUS_COMPLETED` - 任务成功完成
- `TASK_STATUS_FAILED` - 任务执行失败
- `TASK_STATUS_CANCELLED` - 任务已被取消
- `TASK_STATUS_TIMEOUT` - 任务超出超时

## 示例

### 基本任务提交

```bash
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "法国的首都是什么？"
  }'
```

**响应**：
```json
{
  "task_id": "task_01HQZX3Y9K8M2P4N5S7T9W2V",
  "status": "TASK_STATUS_QUEUED",
  "message": "任务已成功提交",
  "created_at": "2025-10-22T10:30:00Z"
}
```

### 带会话 ID 的任务（多轮对话）

```bash
# 第一轮
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "Python 是什么？",
    "session_id": "user-123-chat"
  }'

# 第二轮（引用之前的上下文）
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "它的主要优点是什么？",
    "session_id": "user-123-chat"
  }'
```

### 带上下文的任务

```bash
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "总结此用户反馈",
    "context": {
      "user_id": "user_12345",
      "feedback_type": "bug_report",
      "severity": "high",
      "product": "mobile_app",
      "role": "analysis",
      "model_override": "gpt-4.1"
    }
  }'
```

### 强制层级（顶层）

```bash
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "复杂分析",
    "model_tier": "large"
  }'
```

### 仅模板执行

```bash
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "每周研究简报",
    "context": {"template": "research_summary", "template_version": "1.0.0", "disable_ai": true}
  }'
```

### 监督者模式（Supervisor）

```bash
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "评估系统可靠性",
    "mode": "supervisor"
  }'
```

### 带幂等性

```bash
# 生成幂等性密钥（使用 UUID）
IDEMPOTENCY_KEY=$(uuidgen)

curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "Idempotency-Key: $IDEMPOTENCY_KEY" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "分析 Q4 销售数据"
  }'
```

### 带分布式追踪

```bash
curl -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: sk_test_123456" \\
  -H "traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "研究最新的人工智能趋势"
  }'
```

## 错误响应

### 400 错误的请求

**缺少查询**：
```json
{
  "error": "Query is required"
}
```

**无效的 JSON**：
```json
{
  "error": "Invalid request body: unexpected EOF"
}
```

### 401 未授权

**缺少 API 密钥**：
```json
{
  "error": "Unauthorized"
}
```

**无效的 API 密钥**：
```json
{
  "error": "Unauthorized"
}
```

### 429 请求过多

```json
{
  "error": "Rate limit exceeded"
}
```

**响应头**：
- `X-RateLimit-Limit: 100`
- `X-RateLimit-Remaining: 0`
- `X-RateLimit-Reset: 1609459200`
- `Retry-After: 60`

### 500 内部服务器错误

```json
{
  "error": "Failed to submit task: database connection failed"
}
```

## 代码示例

### Python with httpx

```python
import httpx

response = httpx.post(
    "http://localhost:8080/api/v1/tasks",
    headers={
        "X-API-Key": "sk_test_123456",
        "Content-Type": "application/json"
    },
    json={
        "query": "法国的首都是什么？"
    }
)

if response.status_code == 200:
    data = response.json()
    print(f"任务 ID：{data['task_id']}")
    print(f"状态：{data['status']}")
else:
    print(f"错误：{response.status_code}")
    print(response.json())
```

### Python with requests

```python
import requests

response = requests.post(
    "http://localhost:8080/api/v1/tasks",
    headers={
        "X-API-Key": "sk_test_123456"
    },
    json={
        "query": "分析客户情绪",
        "context": {
            "source": "twitter",
            "date_range": "2025-10-01 to 2025-10-22"
        }
    }
)

task = response.json()
print(f"任务已提交：{task['task_id']}")
```

### JavaScript/Node.js

```javascript
const axios = require('axios');

async function submitTask(query) {
  try {
    const response = await axios.post(
      'http://localhost:8080/api/v1/tasks',
      {
        query: query
      },
      {
        headers: {
          'X-API-Key': 'sk_test_123456',
          'Content-Type': 'application/json'
        }
      }
    );

    console.log('任务 ID：', response.data.task_id);
    console.log('状态：', response.data.status);

    return response.data;
  } catch (error) {
    console.error('错误：', error.response?.data || error.message);
    throw error;
  }
}

submitTask('什么是量子计算？');
```

### cURL with 幂等性

```bash
#!/bin/bash

API_KEY="sk_test_123456"
IDEMPOTENCY_KEY=$(uuidgen)

# 提交任务
RESPONSE=$(curl -s -X POST http://localhost:8080/api/v1/tasks \\
  -H "X-API-Key: $API_KEY" \\
  -H "Idempotency-Key: $IDEMPOTENCY_KEY" \\
  -H "Content-Type: application/json" \\
  -d '{
    "query": "分析 Q4 收入趋势"
  }')

echo $RESPONSE | jq

TASK_ID=$(echo $RESPONSE | jq -r '.task_id')
echo "追踪进度：http://localhost:8088/workflows/$TASK_ID"
```

### Go

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type TaskRequest struct {
    Query     string                 `json:"query"`
    SessionID string                 `json:"session_id,omitempty"`
    Context   map[string]interface{} `json:"context,omitempty"`
}

type TaskResponse struct {
    TaskID    string `json:"task_id"`
    Status    string `json:"status"`
    Message   string `json:"message,omitempty"`
}

func submitTask(query string) (*TaskResponse, error) {
    req := TaskRequest{
        Query: query,
    }

    body, _ := json.Marshal(req)

    httpReq, _ := http.NewRequest(
        "POST",
        "http://localhost:8080/api/v1/tasks",
        bytes.NewBuffer(body),
    )

    httpReq.Header.Set("X-API-Key", "sk_test_123456")
    httpReq.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    resp, err := client.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var taskResp TaskResponse
    json.NewDecoder(resp.Body).Decode(&taskResp)

    return &taskResp, nil
}

func main() {
    task, err := submitTask("什么是机器学习？")
    if err != nil {
        fmt.Println("错误：", err)
        return
    }

    fmt.Printf("任务 ID：%s\n", task.TaskID)
    fmt.Printf("状态：%s\n", task.Status)
}
```

## 实现详情

### 工作流创建

提交任务时：

1. **网关接收请求** → 验证身份验证、速率限制
2. **生成会话 ID** → 如果未提供，自动生成 UUID
3. **调用 Orchestrator gRPC** → `SubmitTask(metadata, query, context)`
4. **Orchestrator 启动 Temporal 工作流** → 持久执行
5. **返回响应** → 任务 ID、初始状态
6. **任务异步执行** → 独立于 HTTP 连接

### 幂等性行为

- **首次请求**：创建新任务，在 Redis 中缓存响应
- **重复请求**（相同的 `Idempotency-Key`）：返回缓存的响应
- **缓存 TTL**：24 小时
- **缓存密钥格式**：`idempotency:{key}`

### 会话管理

- **无 session_id**：自动生成 UUID、新鲜上下文
- **带 session_id**：从 Redis 加载以前的对话历史
- **会话持久性**：默认 TTL 30 天
- **多轮对话**：具有相同 `session_id` 的所有任务共享上下文

### 上下文对象

`context` 对象存储为元数据并传递给：
- 代理执行环境
- 工具调用（可通过 `ctx.get("key")` 访问）
- 会话内存（供将来轮次参考）

**示例使用场景**：
- 用户偏好：`{"language": "spanish", "format": "markdown"}`
- 业务上下文：`{"company_id": "acme", "department": "sales"}`
- 约束：`{"max_length": 500, "tone": "formal"}`

## 最佳实践

### 1. 始终为关键任务使用幂等性密钥

```python
import uuid

idempotency_key = str(uuid.uuid4())

response = httpx.post(
    "http://localhost:8080/api/v1/tasks",
    headers={
        "X-API-Key": "sk_test_123456",
        "Idempotency-Key": idempotency_key
    },
    json={"query": "处理订单 #12345 的付款"}
)
```

### 2. 对对话使用会话

```python
session_id = "user-456-chat"

# 轮次 1
httpx.post(..., json={
    "query": "加载 Q4 销售数据",
    "session_id": session_id
})

# 轮次 2（引用第一轮中的 Q4 数据）
httpx.post(..., json={
    "query": "将其与 Q3 比较",
    "session_id": session_id
})
```

### 3. 提供丰富的上下文

```python
httpx.post(..., json={
    "query": "分析此客户反馈",
    "context": {
        "customer_id": "cust_789",
        "subscription_tier": "enterprise",
        "account_age_days": 365,
        "previous_tickets": 3,
        "sentiment_history": ["positive", "neutral", "negative"]
    }
})
```

### 4. 妥善处理错误

```python
try:
    response = httpx.post(..., timeout=30.0)
    response.raise_for_status()
    task = response.json()
except httpx.TimeoutException:
    print("请求超时")
except httpx.HTTPStatusError as e:
    if e.response.status_code == 429:
        retry_after = int(e.response.headers.get("Retry-After", 60))
        time.sleep(retry_after)
        # 重试...
    else:
        print(f"错误：{e.response.json()}")
```

### 5. 存储任务 ID 以供追踪

```python
response = httpx.post(...)
task_id = response.json()["task_id"]
workflow_id = response.headers["X-Workflow-ID"]

# 保存到数据库
db.tasks.insert({
    "task_id": task_id,
    "workflow_id": workflow_id,
    "user_id": "user_123",
    "query": "...",
    "created_at": datetime.now()
})

# 稍后：检查状态
status = httpx.get(f"http://localhost:8080/api/v1/tasks/{task_id}")
```

## 一次调用提交 + 流式传输

<Tip>
**需要实时更新？** 使用 `POST /api/v1/tasks/stream` 在一次调用中提交任务并获取流 URL。非常适合需要立即进度更新的前端应用。

查看[统一提交 + 流式传输](/cn/api/rest/streaming#统一提交-流式传输推荐)以获取示例。
</Tip>

## 相关端点

<CardGroup cols={2}>
  <Card title="提交 + 流式传输" icon="bolt" href="/cn/api/rest/streaming#统一提交-流式传输推荐">
    POST /api/v1/tasks/stream（推荐用于 UI）
  </Card>
  <Card title="获取任务状态" icon="circle-info" href="/cn/api/rest/get-status">
    GET /api/v1/tasks/{id}
  </Card>
  <Card title="流式事件" icon="stream" href="/cn/api/rest/streaming">
    实时任务事件
  </Card>
  <Card title="列出任务" icon="list" href="/cn/api/rest/list-tasks">
    GET /api/v1/tasks
  </Card>
  <Card title="Python SDK" icon="python" href="/cn/sdk/python/quickstart">
    使用 SDK 替代
  </Card>
</CardGroup>
