---
title: "æµå¼ç«¯ç‚¹"
description: "é€šè¿‡ SSE å’Œ WebSocket å®æ—¶äº‹ä»¶æµä¼ è¾“"
---

## æ¦‚è¿°

Shannon é€šè¿‡ Server-Sent Events (SSE) å’Œ WebSocket åè®®æä¾›å®æ—¶äº‹ä»¶æµä¼ è¾“ã€‚ä½¿ç”¨æµå¼ä¼ è¾“æ¥ç›‘æ§ä»»åŠ¡æ‰§è¡Œã€æ˜¾ç¤ºè¿›åº¦å¹¶åœ¨ç”Ÿæˆæ—¶æ¥æ”¶ç»“æœã€‚

<Warning>
**è®¤è¯**ï¼šæµå¼ç«¯ç‚¹ä¸å…¶ä»– API ä½¿ç”¨ç›¸åŒçš„è®¤è¯è¯·æ±‚å¤´ã€‚
æµè§ˆå™¨ EventSource æ— æ³•æºå¸¦è‡ªå®šä¹‰è¯·æ±‚å¤´ã€‚
- å¼€å‘ç¯å¢ƒï¼šè®¾ç½® `GATEWAY_SKIP_AUTH=1`ã€‚
- ç”Ÿäº§ç¯å¢ƒï¼šé€šè¿‡åç«¯ä»£ç†è½¬å‘ SSEï¼Œå¹¶æ³¨å…¥ `X-API-Key` æˆ– Bearer å¤´ã€‚
ä¸è¦é€šè¿‡ URL æŸ¥è¯¢å‚æ•°ä¼ é€’ API å¯†é’¥ã€‚
</Warning>

<Note>
**æµå¼ä¼ è¾“é™åˆ¶**ï¼š
- **è¶…æ—¶**ï¼šæµåœ¨ 5 åˆ†é’Ÿæ— æ´»åŠ¨åè‡ªåŠ¨å…³é—­
- **ç¼“å†²åŒºå¤§å°**ï¼šæ¯ä¸ªè¿æ¥æœ€å¤§ 1MB ç¼“å†²æ•°æ®
- **ä½¿ç”¨å…ƒæ•°æ®**ï¼šç°åœ¨æ‰€æœ‰ LLM æä¾›å•†ï¼ˆOpenAIã€Anthropicã€Googleã€Groqã€xAIï¼‰éƒ½å¯è·å– token è®¡æ•°å’Œæˆæœ¬
</Note>

## ç«¯ç‚¹

| æ–¹æ³• | ç«¯ç‚¹ | åè®® | æè¿° |
|-----|------|------|------|
| `POST` | `/api/v1/tasks/stream` | HTTP+SSE | æäº¤ä»»åŠ¡å¹¶è·å–æµ URLï¼ˆæ¨èï¼‰ |
| `GET` | `/api/v1/stream/sse` | SSE | Server-Sent Events ç«¯ç‚¹ |
| `GET` | `/api/v1/stream/ws` | WebSocket | WebSocket æµå¼ä¼ è¾“ç«¯ç‚¹ |
| `GET` | `/api/v1/tasks/{id}/events` | HTTP | è·å–å†å²äº‹ä»¶ï¼ˆåˆ†é¡µï¼‰ |

## ç»Ÿä¸€æäº¤ + æµå¼ä¼ è¾“ï¼ˆæ¨èï¼‰

### POST /api/v1/tasks/stream

æäº¤ä»»åŠ¡å¹¶ç«‹å³å¼€å§‹æµå¼ä¼ è¾“å…¶äº‹ä»¶çš„æœ€ç®€å•æ–¹æ³•ã€‚æ­¤ç«¯ç‚¹åœ¨ä¸€æ¬¡è°ƒç”¨ä¸­ç»“åˆäº†ä»»åŠ¡æäº¤å’Œæµå¼è®¾ç½®ã€‚

<Tip>
**æœ€é€‚åˆå‰ç«¯åº”ç”¨**ï¼šæ­¤ç«¯ç‚¹éå¸¸é€‚åˆéœ€è¦åœ¨æäº¤ä»»åŠ¡åç«‹å³æ˜¾ç¤ºè¿›åº¦çš„å®æ—¶ UIã€‚
</Tip>

#### èº«ä»½éªŒè¯

**å¿…éœ€**ï¼šæ˜¯

```
X-API-Key: sk_test_123456
```

æˆ–ï¼š

```
Authorization: Bearer YOUR_TOKEN
```

#### è¯·æ±‚ä½“

| å‚æ•° | ç±»å‹ | å¿…éœ€ | æè¿° |
|------|------|------|------|
| `query` | string | æ˜¯ | è‡ªç„¶è¯­è¨€ä»»åŠ¡æè¿° |
| `session_id` | string | å¦ | å¤šè½®å¯¹è¯çš„ä¼šè¯æ ‡è¯†ç¬¦ |
| `context` | object | å¦ | é”®å€¼å¯¹å½¢å¼çš„é™„åŠ ä¸Šä¸‹æ–‡æ•°æ® |
| `model_tier` | string | å¦ | æ¨¡å‹å±‚çº§ï¼š`small`ã€`medium`ã€`large` |
| `model_override` | string | å¦ | æŒ‡å®šæ¨¡å‹åç§°ï¼ˆè§„èŒƒ IDï¼›ä¾‹å¦‚ `gpt-5`ï¼‰ |
| `provider_override` | string | å¦ | å¼ºåˆ¶æŒ‡å®šæä¾›å•†ï¼ˆå¦‚ `openai`ã€`anthropic`ã€`google`ï¼‰ |

#### å“åº”

**çŠ¶æ€**ï¼š`201 Created`

**å“åº”ä½“**ï¼š
```json
{
  "task_id": "task_01HQZX3Y9K8M2P4N5S7T9W2V",
  "workflow_id": "task_01HQZX3Y9K8M2P4N5S7T9W2V",
  "stream_url": "/api/v1/stream/sse?workflow_id=task_01HQZX3Y9K8M2P4N5S7T9W2V"
}
```

#### å“åº”å­—æ®µ

| å­—æ®µ | ç±»å‹ | æè¿° |
|------|------|------|
| `workflow_id` | string | ä»»åŠ¡/å·¥ä½œæµæ ‡è¯†ç¬¦ |
| `stream_url` | string | SSE æµç«¯ç‚¹çš„ç›¸å¯¹ URL |

#### ç¤ºä¾‹ï¼šJavaScript/TypeScript

```javascript
async function submitAndStream(query, onEvent, onComplete, onError) {
  try {
    // 1. æäº¤ä»»åŠ¡å¹¶è·å–æµ URL
    const response = await fetch('http://localhost:8080/api/v1/tasks/stream', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer YOUR_TOKEN'
      },
      body: JSON.stringify({
        query: query,
        session_id: `session-${Date.now()}`
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const { task_id, workflow_id, stream_url } = await response.json();
    console.log(`ä»»åŠ¡å·²æäº¤: ${workflow_id}`);

    // 2. è¿æ¥åˆ° SSE æµ
    const eventSource = new EventSource(
      `http://localhost:8080${stream_url}`,
      { withCredentials: false }
    );

    eventSource.onmessage = (e) => {
      const event = JSON.parse(e.data);
      onEvent(event);

      // æ£€æŸ¥å®ŒæˆçŠ¶æ€
      if (event.type === 'WORKFLOW_COMPLETED') {
        eventSource.close();
        onComplete(event);
      }
    };

    eventSource.onerror = (err) => {
      console.error('SSE é”™è¯¯:', err);
      eventSource.close();
      onError(err);
    };

    return { workflow_id, eventSource };

  } catch (error) {
    onError(error);
    throw error;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
submitAndStream(
  "åˆ†æç¬¬å››å­£åº¦æ”¶å…¥è¶‹åŠ¿",
  (event) => console.log(`[${event.type}]`, event.message),
  (final) => console.log("å·²å®Œæˆ:", final.result),
  (error) => console.error("é”™è¯¯:", error)
);
```

#### ç¤ºä¾‹ï¼šReact Hook

```jsx
import { useState, useCallback, useRef } from 'react';

function useTaskStream(apiUrl = 'http://localhost:8080') {
  const [events, setEvents] = useState([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState(null);
  const [workflowId, setWorkflowId] = useState(null);
  const eventSourceRef = useRef(null);

  const submitTask = useCallback(async (query, sessionId = null) => {
    setEvents([]);
    setError(null);
    setIsStreaming(true);

    try {
      // æäº¤ä»»åŠ¡
      const response = await fetch(`${apiUrl}/api/v1/tasks/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify({
          query,
          session_id: sessionId || `session-${Date.now()}`
        })
      });

      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const { task_id, workflow_id, stream_url } = await response.json();
      setWorkflowId(workflow_id);

      // è¿æ¥åˆ°æµ
      const eventSource = new EventSource(`${apiUrl}${stream_url}`);
      eventSourceRef.current = eventSource;

      eventSource.onmessage = (e) => {
        const event = JSON.parse(e.data);
        setEvents(prev => [...prev, event]);

        if (event.type === 'WORKFLOW_COMPLETED' || event.type === 'ERROR_OCCURRED') {
          eventSource.close();
          setIsStreaming(false);
        }
      };

      eventSource.onerror = (err) => {
        setError(err);
        setIsStreaming(false);
        eventSource.close();
      };

    } catch (err) {
      setError(err);
      setIsStreaming(false);
    }
  }, [apiUrl]);

  const stopStreaming = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      setIsStreaming(false);
    }
  }, []);

  return { submitTask, stopStreaming, events, isStreaming, error, workflowId };
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
function TaskStreamDemo() {
  const { submitTask, stopStreaming, events, isStreaming, error, workflowId } = useTaskStream();

  return (
    <div>
      <button
        onClick={() => submitTask("15 + 25 ç­‰äºå¤šå°‘ï¼Ÿ")}
        disabled={isStreaming}
      >
        {isStreaming ? 'å¤„ç†ä¸­...' : 'æäº¤ä»»åŠ¡'}
      </button>

      {workflowId && <p>å·¥ä½œæµ ID: {workflowId}</p>}
      {error && <p style={{color: 'red'}}>é”™è¯¯: {error.message}</p>}

      <div>
        {events.map((event, idx) => (
          <div key={idx}>
            <strong>{event.type}</strong>: {event.message || event.agent_id}
          </div>
        ))}
      </div>

      {isStreaming && <button onClick={stopStreaming}>åœæ­¢</button>}
    </div>
  );
}
```

#### ç¤ºä¾‹ï¼šVue 3 Composition API

```vue
<script setup>
import { ref } from 'vue';

const events = ref([]);
const isStreaming = ref(false);
const error = ref(null);
const workflowId = ref(null);
let eventSource = null;

async function submitTask(query) {
  events.value = [];
  error.value = null;
  isStreaming.value = true;

  try {
    const response = await fetch('http://localhost:8080/api/v1/tasks/stream', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify({
        query,
        session_id: `session-${Date.now()}`
      })
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    const { workflow_id, stream_url } = await response.json();
    workflowId.value = workflow_id;

    eventSource = new EventSource(`http://localhost:8080${stream_url}`);

    eventSource.onmessage = (e) => {
      const event = JSON.parse(e.data);
      events.value.push(event);

      if (event.type === 'WORKFLOW_COMPLETED') {
        eventSource.close();
        isStreaming.value = false;
      }
    };

    eventSource.onerror = (err) => {
      error.value = err;
      eventSource.close();
      isStreaming.value = false;
    };
  } catch (err) {
    error.value = err;
    isStreaming.value = false;
  }
}

function stopStreaming() {
  if (eventSource) {
    eventSource.close();
    isStreaming.value = false;
  }
}
</script>

<template>
  <div>
    <button @click="submitTask('åˆ†ææ•°æ®')" :disabled="isStreaming">
      {{ isStreaming ? 'å¤„ç†ä¸­...' : 'æäº¤ä»»åŠ¡' }}
    </button>

    <div v-if="workflowId">å·¥ä½œæµ: {{ workflowId }}</div>
    <div v-if="error" style="color: red">é”™è¯¯: {{ error.message }}</div>

    <div v-for="(event, idx) in events" :key="idx">
      <strong>{{ event.type }}</strong>: {{ event.message || event.agent_id }}
    </div>

    <button v-if="isStreaming" @click="stopStreaming">åœæ­¢</button>
  </div>
</template>
```

#### ç¤ºä¾‹ï¼šPython

```python
import httpx
import json
import time

def submit_and_stream(query: str, api_key: str):
    """æäº¤ä»»åŠ¡å¹¶æµå¼ä¼ è¾“äº‹ä»¶ã€‚"""

    # 1. æäº¤ä»»åŠ¡
    response = httpx.post(
        "http://localhost:8080/api/v1/tasks/stream",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json={
            "query": query,
            "session_id": f"session-{int(time.time())}"
        }
    )

    data = response.json()
    workflow_id = data["workflow_id"]
    stream_url = data["stream_url"]

    print(f"ä»»åŠ¡å·²æäº¤: {workflow_id}")

    # 2. æµå¼ä¼ è¾“äº‹ä»¶
    with httpx.stream(
        "GET",
        f"http://localhost:8080{stream_url}",
        headers={"Authorization": f"Bearer {api_key}"},
        timeout=None
    ) as stream_response:
        for line in stream_response.iter_lines():
            if line.startswith("data:"):
                event = json.loads(line[5:])
                print(f"[{event['type']}] {event.get('message', '')}")

                if event['type'] in ['WORKFLOW_COMPLETED']:
                    return event

# ä½¿ç”¨ç¤ºä¾‹
result = submit_and_stream("æ³•å›½çš„é¦–éƒ½æ˜¯ä»€ä¹ˆï¼Ÿ", "sk_test_123456")
print("æœ€ç»ˆç»“æœ:", result.get('result'))
```

<Note>
**ä¸ºä»€ä¹ˆä½¿ç”¨æ­¤ç«¯ç‚¹ï¼Ÿ** ç»Ÿä¸€ç«¯ç‚¹ç¡®ä¿æ‚¨åœ¨æäº¤åç«‹å³å¼€å§‹æµå¼ä¼ è¾“ï¼Œé˜²æ­¢åœ¨åˆ†åˆ«æäº¤å’Œè¿æ¥æ—¶å¯èƒ½é”™è¿‡çš„ä»»ä½•äº‹ä»¶ã€‚
</Note>

## Server-Sent Events (SSE)

### GET /api/v1/stream/sse

ä½¿ç”¨ Server-Sent Events è¿›è¡Œå®æ—¶äº‹ä»¶æµä¼ è¾“ã€‚

#### èº«ä»½éªŒè¯

**å¿…éœ€**ï¼šæ˜¯

```
X-API-Key: sk_test_123456
```

#### æŸ¥è¯¢å‚æ•°

| å‚æ•° | ç±»å‹ | å¿…éœ€ | æè¿° |
|------|------|------|------|
| `workflow_id` | string | æ˜¯ | ä»»åŠ¡/å·¥ä½œæµæ ‡è¯†ç¬¦ |
| `types` | string | å¦ | é€—å·åˆ†éš”çš„äº‹ä»¶ç±»å‹ä»¥ç­›é€‰ |
| `last_event_id` | string | å¦ | ä»ç‰¹å®šäº‹ä»¶ ID æ¢å¤ã€‚æ”¯æŒ Redis Stream IDï¼ˆå¦‚ `1700000000000-0`ï¼‰æˆ–æ•°å­—åºå·ï¼ˆå¦‚ `42`ï¼‰ã€‚å½“ä¸ºæ•°å­—æ—¶ï¼Œé‡æ”¾è§„åˆ™ä¸º `seq > last_event_id`ã€‚ |

#### äº‹ä»¶æ ¼å¼

æ¯ä¸ªäº‹ä»¶éµå¾ª SSE è§„èŒƒï¼š

```
id: <event_id>
event: <event_type>
data: <json_payload>

```

#### ç¤ºä¾‹è¯·æ±‚

```bash
curl -N "http://localhost:8080/api/v1/stream/sse?workflow_id=task_abc123" \\
  -H "X-API-Key: sk_test_123456"
```

#### ç¤ºä¾‹å“åº”

```
id: 1
event: WORKFLOW_STARTED
data: {"workflow_id":"task_abc123","timestamp":"2025-10-22T10:30:00Z","message":"å·¥ä½œæµå·²å¯åŠ¨"}

id: 2
event: AGENT_THINKING
data: {"workflow_id":"task_abc123","agent_id":"agent_1","message":"åˆ†ææŸ¥è¯¢...","timestamp":"2025-10-22T10:30:01Z"}

id: 3
event: TOOL_INVOKED
data: {"workflow_id":"task_abc123","tool":"web_search","params":{"query":"Python ç¼–ç¨‹"},"timestamp":"2025-10-22T10:30:02Z"}

id: 4
event: TOOL_OBSERVATION
data: {"workflow_id":"task_abc123","tool":"web_search","result":"...","timestamp":"2025-10-22T10:30:05Z"}

id: 5
event: AGENT_COMPLETED
data: {"workflow_id":"task_abc123","agent_id":"agent_1","result":"Python æ˜¯ä¸€ç§é«˜çº§ç¼–ç¨‹è¯­è¨€...","timestamp":"2025-10-22T10:30:06Z"}

id: 6
event: WORKFLOW_COMPLETED
data: {"workflow_id":"task_abc123","status":"COMPLETED","result":"...","timestamp":"2025-10-22T10:30:07Z"}
```

## WebSocket

### GET /api/v1/stream/ws

é€šè¿‡ WebSocket è¿›è¡ŒåŒå‘æµå¼ä¼ è¾“ã€‚

#### èº«ä»½éªŒè¯

ç½‘å…³é€šè¿‡ä»…ä½¿ç”¨æ ‡å¤´ï¼ˆ`X-API-Key` æˆ– `Authorization`ï¼‰æ¥å¯¹ WebSocket è¿æ¥è¿›è¡Œèº«ä»½éªŒè¯ã€‚æµè§ˆå™¨åœ¨ WebSocket æ¡æ‰‹æœŸé—´æ— æ³•è®¾ç½®è‡ªå®šä¹‰æ ‡å¤´ã€‚å¯¹äºæµè§ˆå™¨ä½¿ç”¨ï¼š

- ä»¥ `GATEWAY_SKIP_AUTH=1` æœ¬åœ°è¿è¡Œï¼Œæˆ–
- ä½¿ç”¨åå‘ä»£ç†åœ¨è½¬å‘åˆ°ç½‘å…³ä¹‹å‰æ³¨å…¥æ ‡å¤´ã€‚

æœåŠ¡å™¨ç¯å¢ƒä¸­åŸºäºæ ‡å¤´çš„ç¤ºä¾‹ï¼š

Node (ws)ï¼š
```js
import WebSocket from 'ws';

const ws = new WebSocket('ws://localhost:8080/api/v1/stream/ws', {
  headers: { 'X-API-Key': 'sk_test_123456' },
});

ws.on('open', () => {
  ws.send(JSON.stringify({ type: 'subscribe', workflow_id: 'task_abc123' }));
});

ws.on('message', (msg) => {
  const data = JSON.parse(msg.toString());
  console.log('äº‹ä»¶ï¼š', data.type, data.message);
});

ws.on('error', (err) => console.error('WebSocket é”™è¯¯ï¼š', err));
```

Python (websockets)ï¼š
```python
import asyncio, json, websockets

async def main():
    async with websockets.connect(
        'ws://localhost:8080/api/v1/stream/ws',
        extra_headers={'X-API-Key': 'sk_test_123456'},
    ) as ws:
        await ws.send(json.dumps({'type': 'subscribe', 'workflow_id': 'task_abc123'}))
        async for message in ws:
            data = json.loads(message)
            print('äº‹ä»¶ï¼š', data.get('type'), data.get('message'))

asyncio.run(main())
```

<Note>
ä¸æ”¯æŒé€šè¿‡æŸ¥è¯¢å­—ç¬¦ä¸²ä¼ é€’ API å¯†é’¥æˆ–é€šè¿‡ç½‘å…³çš„è¿æ¥å"auth"æ¶ˆæ¯ã€‚
</Note>

#### æ¶ˆæ¯ç±»å‹

**å®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨**ï¼š

```json
// è®¢é˜…å·¥ä½œæµ
{
  "type": "subscribe",
  "workflow_id": "task_abc123",
  "types": ["AGENT_THINKING", "TOOL_INVOKED"]
}

// å–æ¶ˆè®¢é˜…
{
  "type": "unsubscribe",
  "workflow_id": "task_abc123"
}

// Pingï¼ˆä¿æ´»ï¼‰
{
  "type": "ping"
}
```

**æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯**ï¼š

```json
// äº‹ä»¶
{
  "type": "AGENT_THINKING",
  "workflow_id": "task_abc123",
  "message": "åˆ†ææŸ¥è¯¢...",
  "timestamp": "2025-10-22T10:30:00Z"
}

// Pongï¼ˆä¿æ´»å“åº”ï¼‰
{
  "type": "pong"
}
```

## äº‹ä»¶ç±»å‹

### æ ¸å¿ƒäº‹ä»¶

| äº‹ä»¶ç±»å‹ | æè¿° | ä½•æ—¶è§¦å‘ |
|---------|------|---------|
| `WORKFLOW_STARTED` | å·¥ä½œæµæ‰§è¡Œå¼€å§‹ | ä»»åŠ¡å¼€å§‹ |
| `WORKFLOW_COMPLETED` | å·¥ä½œæµæˆåŠŸå®Œæˆ | ä»»åŠ¡ç»“æŸï¼ˆæˆåŠŸï¼‰ |

### ä»£ç†äº‹ä»¶

| äº‹ä»¶ç±»å‹ | æè¿° | è½½è·å­—æ®µ |
|---------|------|---------|
| `AGENT_THINKING` | ä»£ç†æ¨ç†/è§„åˆ’ | `agent_id`ã€`message` |
| `AGENT_COMPLETED` | ä»£ç†å®Œæˆæ‰§è¡Œ | `agent_id`ã€`result` |

### å·¥å…·äº‹ä»¶

| äº‹ä»¶ç±»å‹ | æè¿° | è½½è·å­—æ®µ |
|---------|------|---------|
| `TOOL_INVOKED` | å·¥å…·æ‰§è¡Œå·²å¯åŠ¨ | `tool`ã€`params` |
| `TOOL_OBSERVATION` | ä»£ç†è§‚å¯Ÿå·¥å…·ç»“æœ | `tool`ã€`result` |

### LLM äº‹ä»¶

| äº‹ä»¶ç±»å‹ | æè¿° | è½½è·å­—æ®µ |
|---------|------|---------|
| `LLM_PROMPT` | å‘é€ç»™ LLM çš„æç¤º | `text` |
| `LLM_PARTIAL` | æµå¼ LLM è¾“å‡º | `text` |
| `LLM_OUTPUT` | æœ€ç»ˆ LLM è¾“å‡º | `text` |

### è¿›åº¦ä¸ç³»ç»Ÿäº‹ä»¶

| äº‹ä»¶ç±»å‹ | æè¿° | è½½è·å­—æ®µ |
|---------|------|---------|
| `PROGRESS` | è¿›åº¦æ›´æ–° | `progress`ã€`message` |
| `DATA_PROCESSING` | æ•°æ®å¤„ç†ä¸­ | `message` |
| `WAITING` | ç­‰å¾…èµ„æº | `message` |
| `ERROR_OCCURRED` | å‘ç”Ÿé”™è¯¯ | `error`ã€`severity` |
| `ERROR_RECOVERY` | é”™è¯¯æ¢å¤å°è¯• | `message` |
| `WORKSPACE_UPDATED` | å†…å­˜/ä¸Šä¸‹æ–‡å·²æ›´æ–° | `message` |

### å›¢é˜Ÿä¸å®¡æ‰¹

| äº‹ä»¶ç±»å‹ | æè¿° |
|------------|-------------|
| `TEAM_RECRUITED` | ç»„å»ºå¤šæ™ºèƒ½ä½“å›¢é˜Ÿ |
| `TEAM_RETIRED` | è§£æ•£å›¢é˜Ÿ |
| `TEAM_STATUS` | å›¢é˜Ÿåè°ƒæ›´æ–° |
| `ROLE_ASSIGNED` | åˆ†é…ä»£ç†è§’è‰² |
| `DELEGATION` | ä»»åŠ¡å·²å§”æ‰˜ |
| `DEPENDENCY_SATISFIED` | ä¾èµ–å·²è§£å†³ |
| `APPROVAL_REQUESTED` | éœ€è¦äººå·¥æ‰¹å‡† |
| `APPROVAL_DECISION` | å®¡æ‰¹å†³ç­–å·²è®°å½• |

## ä»£ç ç¤ºä¾‹

### Python with httpx (SSE)

```python
import httpx
import json

def stream_task_events(task_id: str, api_key: str):
    """ä½¿ç”¨ SSE æµå¼ä¼ è¾“ä»»åŠ¡äº‹ä»¶ã€‚"""
    url = f"http://localhost:8080/api/v1/stream/sse?workflow_id={task_id}"

    with httpx.stream(
        "GET",
        url,
        headers={"X-API-Key": api_key},
        timeout=None  # æ— æµå¼ä¼ è¾“è¶…æ—¶
    ) as response:
        for line in response.iter_lines():
            if line.startswith("data:"):
                data = json.loads(line[5:])  # ç§»é™¤"data:"å‰ç¼€
                yield data

# ç”¨æ³•
for event in stream_task_events("task_abc123", "sk_test_123456"):
    print(f"[{event.get('type')}] {event.get('message', '')}")

    if event.get('type') == 'WORKFLOW_COMPLETED':
        print("æœ€ç»ˆç»“æœï¼š", event.get('result'))
        break
```

### Python - æµå¼ä¼ è¾“å¸¦äº‹ä»¶ç­›é€‰

```python
def stream_filtered_events(task_id: str, api_key: str, event_types: list):
    """ä»…æµå¼ä¼ è¾“ç‰¹å®šäº‹ä»¶ç±»å‹ã€‚"""
    types_param = ",".join(event_types)
    url = f"http://localhost:8080/api/v1/stream/sse?workflow_id={task_id}&types={types_param}"

    with httpx.stream("GET", url, headers={"X-API-Key": api_key}) as response:
        for line in response.iter_lines():
            if line.startswith("data:"):
                yield json.loads(line[5:])

# ä»…æ¥æ”¶ä»£ç†æ€è€ƒå’Œå·¥å…·äº‹ä»¶
for event in stream_filtered_events(
    "task_abc123",
    "sk_test_123456",
    ["AGENT_THINKING", "TOOL_INVOKED", "TOOL_OBSERVATION"]
):
    print(f"{event['type']}ï¼š{event.get('message', event.get('tool'))}")
```

### JavaScript/Node.js (SSE)

```javascript
const EventSource = require('eventsource');

function streamTaskEvents(taskId, apiKey) {
  const url = `http://localhost:8080/api/v1/stream/sse?workflow_id=${taskId}`;

  const eventSource = new EventSource(url, {
    headers: {
      'X-API-Key': apiKey
    }
  });

  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log(`[${data.type}] ${data.message || ''}`);

    if (data.type === 'WORKFLOW_COMPLETED') {
      console.log('æœ€ç»ˆç»“æœï¼š', data.result);
      eventSource.close();
    }
  };

  eventSource.onerror = (error) => {
    console.error('SSE é”™è¯¯ï¼š', error);
    eventSource.close();
  };

  return eventSource;
}

// ç”¨æ³•
const stream = streamTaskEvents('task_abc123', 'sk_test_123456');

// æ‰‹åŠ¨å…³é—­
setTimeout(() => stream.close(), 60000);
```

### JavaScript/Node.js - WebSocket (ws)

```javascript
import WebSocket from 'ws';

function connectWebSocket(taskId, apiKey) {
  const ws = new WebSocket(
    `ws://localhost:8080/api/v1/stream/ws?workflow_id=${taskId}`,
    { headers: { 'X-API-Key': apiKey } }
  );

  ws.on('open', () => console.log('âœ“ å·²è¿æ¥'));

  ws.on('message', (msg) => {
    const data = JSON.parse(msg.toString());
    switch (data.type) {
      case 'AGENT_THINKING':
        console.log(`ğŸ’­ ${data.message}`);
        break;
      case 'TOOL_INVOKED':
        console.log(`ğŸ”§ å·¥å…·ï¼š${data.tool}`);
        break;
      case 'TOOL_OBSERVATION':
        console.log(`âœ“ ç»“æœï¼š${data.result}`);
        break;
      case 'WORKFLOW_COMPLETED':
        console.log(`âœ“ å®Œæˆï¼š${data.result}`);
        ws.close();
        break;
      default:
        console.log(`[${data.type}] ${data.message || ''}`);
    }
  });

  ws.on('error', (err) => console.error('âŒ é”™è¯¯ï¼š', err));
  ws.on('close', () => console.log('è¿æ¥å·²å…³é—­'));

  return ws;
}

const ws = connectWebSocket('task_abc123', 'sk_test_123456');
```

### Go (SSE)

```go
package main

import (
    "bufio"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
)

type Event struct {
    Type      string                 `json:"type"`
    WorkflowID string                `json:"workflow_id"`
    Message   string                 `json:"message,omitempty"`
    Data      map[string]interface{} `json:",inline"`
}

func streamEvents(taskID, apiKey string) error {
    url := fmt.Sprintf(
        "http://localhost:8080/api/v1/stream/sse?workflow_id=%s",
        taskID,
    )

    req, _ := http.NewRequest("GET", url, nil)
    req.Header.Set("X-API-Key", apiKey)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    scanner := bufio.NewScanner(resp.Body)

    for scanner.Scan() {
        line := scanner.Text()

        if strings.HasPrefix(line, "data:") {
            data := strings.TrimPrefix(line, "data:")

            var event Event
            json.Unmarshal([]byte(data), &event)

            fmt.Printf("[%s] %s\n", event.Type, event.Message)

            if event.Type == "WORKFLOW_COMPLETED" {
                fmt.Println("âœ“ ä»»åŠ¡å®Œæˆ")
                break
            }
        }
    }

    return scanner.Err()
}

func main() {
    err := streamEvents("task_abc123", "sk_test_123456")
    if err != nil {
        fmt.Println("é”™è¯¯ï¼š", err)
    }
}
```

### Bash/curl (SSE)

```bash
#!/bin/bash

API_KEY="sk_test_123456"
TASK_ID="$1"

curl -N "http://localhost:8080/api/v1/stream/sse?workflow_id=$TASK_ID" \\
  -H "X-API-Key: $API_KEY" \\
  | while IFS= read -r line; do
    if [[ $line == data:* ]]; then
      # ä»"dataï¼š{...}"æå– JSON
      JSON="${line#data:}"

      # è§£æå¹¶æ˜¾ç¤º
      TYPE=$(echo "$JSON" | jq -r '.type')
      MESSAGE=$(echo "$JSON" | jq -r '.message // ""')

      echo "[$(date +%T)] $TYPEï¼š$MESSAGE"

      # å®Œæˆæ—¶é€€å‡º
      if [[ "$TYPE" == "WORKFLOW_COMPLETED" ]]; then
        echo ""
        echo "$JSON" | jq -r '.result'
        break
      fi
    fi
  done
```

## ç”¨ä¾‹

### 1. å®æ—¶è¿›åº¦æ˜¾ç¤º

```python
def display_progress(task_id: str, api_key: str):
    """å‘ç”¨æˆ·æ˜¾ç¤ºå®æ—¶è¿›åº¦ã€‚"""
    print(f"ä»»åŠ¡ {task_id} å¯åŠ¨...")

    for event in stream_task_events(task_id, api_key):
        event_type = event.get('type')

        if event_type == 'AGENT_THINKING':
            print(f"ğŸ’­ {event['message']}")
        elif event_type == 'TOOL_INVOKED':
            print(f"ğŸ”§ ä½¿ç”¨å·¥å…·ï¼š{event['tool']}")
        elif event_type == 'TOOL_OBSERVATION':
            print(f"âœ“ å·¥å…·å·²å®Œæˆ")
        elif event_type == 'LLM_PARTIAL':
            print(event['text'], end='', flush=True)
        elif event_type == 'WORKFLOW_COMPLETED':
            print(f"\n\nâœ“ å®Œæˆï¼")
            return event['result']
```

### 2. å°†æ‰€æœ‰äº‹ä»¶è®°å½•åˆ°æ–‡ä»¶

```python
import json
from datetime import datetime

def log_events_to_file(task_id: str, api_key: str, log_file: str):
    """å°†æ‰€æœ‰äº‹ä»¶è®°å½•åˆ° JSON Lines æ–‡ä»¶ã€‚"""
    with open(log_file, 'a') as f:
        for event in stream_task_events(task_id, api_key):
            # æ·»åŠ æ—¶é—´æˆ³
            event['logged_at'] = datetime.now().isoformat()

            # ä»¥ JSON Lines æ ¼å¼å†™å…¥
            f.write(json.dumps(event) + '\n')
            f.flush()

            if event.get('type') == 'WORKFLOW_COMPLETED':
                break

log_events_to_file("task_abc123", "sk_test_123456", "task_events.jsonl")
```

### 3. æ”¶é›†å·¥å…·ä½¿ç”¨æŒ‡æ ‡

```python
def collect_tool_metrics(task_id: str, api_key: str):
    """æ”¶é›†æœ‰å…³å·¥å…·ä½¿ç”¨çš„æŒ‡æ ‡ã€‚"""
    metrics = {
        "tools_invoked": 0,
        "tools_succeeded": 0,
        "tools_failed": 0,
        "tool_list": []
    }

    for event in stream_task_events(task_id, api_key):
        if event.get('type') == 'TOOL_INVOKED':
            metrics['tools_invoked'] += 1
            metrics['tool_list'].append(event['tool'])
        elif event.get('type') == 'TOOL_OBSERVATION':
            metrics['tools_succeeded'] += 1
        elif event.get('type') == 'ERROR_OCCURRED':
            metrics['tools_failed'] += 1
        elif event.get('type') == 'WORKFLOW_COMPLETED':
            break

    return metrics

metrics = collect_tool_metrics("task_abc123", "sk_test_123456")
print(f"ä½¿ç”¨çš„å·¥å…·ï¼š{metrics['tool_list']}")
print(f"æˆåŠŸç‡ï¼š{metrics['tools_succeeded']}/{metrics['tools_invoked']}")
```

### 4. React UI é›†æˆ

```javascript
import { useState, useEffect } from 'react';

function TaskMonitor({ taskId, apiKey }) {
  const [events, setEvents] = useState([]);
  const [status, setStatus] = useState('connecting');

  useEffect(() => {
    const eventSource = new EventSource(
      `http://localhost:8080/api/v1/stream/sse?workflow_id=${taskId}`,
      { headers: { 'X-API-Key': apiKey } }
    );

    eventSource.onopen = () => setStatus('connected');

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setEvents(prev => [...prev, data]);

      if (data.type === 'WORKFLOW_COMPLETED') {
        setStatus('completed');
        eventSource.close();
      }
    };

    eventSource.onerror = () => {
      setStatus('error');
      eventSource.close();
    };

    return () => eventSource.close();
  }, [taskId, apiKey]);

  return (
    <div>
      <h3>çŠ¶æ€ï¼š{status}</h3>
      <ul>
        {events.map((event, i) => (
          <li key={i}>
            <strong>{event.type}</strong>ï¼š{event.message || event.tool}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## æœ€ä½³å®è·µ

### 1. å¤„ç†è¿æ¥é”™è¯¯

```python
import time

def stream_with_retry(task_id: str, api_key: str, max_retries: int = 3):
    """åœ¨è¿æ¥å¤±è´¥æ—¶è¿›è¡Œè‡ªåŠ¨é‡è¯•çš„æµå¼ä¼ è¾“ã€‚"""
    for attempt in range(max_retries):
        try:
            for event in stream_task_events(task_id, api_key):
                yield event

                if event.get('type') == 'WORKFLOW_COMPLETED':
                    return
        except Exception as e:
            if attempt < max_retries - 1:
                print(f"è¿æ¥å¤±è´¥ï¼Œ{2 ** attempt}s åé‡è¯•...")
                time.sleep(2 ** attempt)
            else:
                raise
```

### 2. å®æ–½è¶…æ—¶

```python
import signal

def stream_with_timeout(task_id: str, api_key: str, timeout: int = 300):
    """å…·æœ‰è¶…æ—¶çš„æµå¼ä¼ è¾“ã€‚"""
    def timeout_handler(signum, frame):
        raise TimeoutError("æµå¼ä¼ è¾“è¶…æ—¶")

    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)

    try:
        for event in stream_task_events(task_id, api_key):
            yield event
            if event.get('type') == 'WORKFLOW_COMPLETED':
                break
    finally:
        signal.alarm(0)  # å–æ¶ˆé—¹é’Ÿ
```

### 3. å®¢æˆ·ç«¯è¿‡æ»¤äº‹ä»¶

```python
def stream_specific_events(task_id: str, api_key: str, event_types: set):
    """å®¢æˆ·ç«¯è¿‡æ»¤äº‹ä»¶ã€‚"""
    for event in stream_task_events(task_id, api_key):
        if event.get('type') in event_types:
            yield event

        if event.get('type') == 'WORKFLOW_COMPLETED':
            yield event
            break

# ä»…æ¥æ”¶ä»£ç†å’Œå·¥å…·äº‹ä»¶
for event in stream_specific_events(
    "task_abc123",
    "sk_test_123456",
    {"AGENT_THINKING", "TOOL_INVOKED", "TOOL_OBSERVATION"}
):
    print(event)
```

### 4. ä»æœ€åä¸€ä¸ªäº‹ä»¶æ¢å¤

```python
def stream_with_resume(task_id: str, api_key: str, last_event_id: str = None):
    """ä»ç‰¹å®šäº‹ä»¶æ¢å¤æµå¼ä¼ è¾“ã€‚"""
    url = f"http://localhost:8080/api/v1/stream/sse?workflow_id={task_id}"

    if last_event_id:
        url += f"&last_event_id={last_event_id}"

    # æµå¼ä¼ è¾“äº‹ä»¶...
```

è¯´æ˜ï¼š`last_event_id` æ”¯æŒ Redis Stream IDï¼ˆå¦‚ `1700000000000-0`ï¼‰æˆ–æ•°å­—åºå·ï¼ˆå¦‚ `42`ï¼‰ã€‚å½“ä¸ºæ•°å­—æ—¶ï¼Œé‡æ”¾è§„åˆ™ä¸º `seq > last_event_id`ã€‚

## æ¯”è¾ƒï¼šSSE vs WebSocket vs è½®è¯¢

| åŠŸèƒ½ | SSE | WebSocket | è½®è¯¢ |
|-----|-----|-----------|-----|
| **æ–¹å‘** | æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯ | åŒå‘ | å®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨ |
| **åè®®** | HTTP | WebSocket | HTTP |
| **è‡ªåŠ¨é‡è¿** | æ˜¯ï¼ˆæµè§ˆå™¨ï¼‰ | å¦ï¼ˆæ‰‹åŠ¨ï¼‰ | N/A |
| **å¼€é”€** | ä½ | éå¸¸ä½ | é«˜ |
| **ç®€æ´æ€§** | é«˜ | ä¸­ | é«˜ |
| **ä½¿ç”¨åœºæ™¯** | å®æ—¶æ›´æ–° | äº¤äº’å¼åº”ç”¨ | ç®€å•çŠ¶æ€ |
| **Shannon æ”¯æŒ** | âœ… æ¨è | âœ… å¯ç”¨ | âš ï¸ ä¸ç†æƒ³ |

### ä½•æ—¶ä½¿ç”¨æ¯ä¸ª

- **SSE**ï¼šå¤§å¤šæ•°ç”¨ä¾‹ã€å®æ—¶ç›‘æ§ã€è¿›åº¦æ˜¾ç¤º
- **WebSocket**ï¼šäº¤äº’å¼åº”ç”¨ã€éœ€è¦åŒå‘é€šä¿¡
- **è½®è¯¢**ï¼ˆGET /api/v1/tasks/{id}ï¼‰ï¼šä¼ ç»Ÿç³»ç»Ÿã€æ— æµå¼ä¼ è¾“æ”¯æŒ

## ç›¸å…³ç«¯ç‚¹

<CardGroup cols={2}>
  <Card title="æäº¤ä»»åŠ¡" icon="paper-plane" href="/cn/api/rest/submit-task">
    POST /api/v1/tasks
  </Card>
  <Card title="è·å–çŠ¶æ€" icon="circle-info" href="/cn/api/rest/get-status">
    GET /api/v1/tasks/{id}
  </Card>
  <Card title="Python SDK" icon="python" href="/cn/sdk/python/quickstart">
    ä½¿ç”¨ client.stream()
  </Card>
</CardGroup>

## æ³¨æ„

<Tip>
**äº‹ä»¶ä¿ç•™**ï¼š
- **Redis**ï¼šæ‰€æœ‰äº‹ä»¶å­˜å‚¨ 24 å°æ—¶ï¼ˆå®æ—¶æµå¼ä¼ è¾“ï¼‰
- **PostgreSQL**ï¼šå…³é”®äº‹ä»¶å­˜å‚¨ 90 å¤©ï¼ˆå†å²æŸ¥è¯¢ï¼‰
- å¦‚æœè¿æ¥æ–­å¼€ï¼Œä½¿ç”¨ `last_event_id` æ¢å¤æµå¼ä¼ è¾“
</Tip>

<Warning>
**è¿æ¥é™åˆ¶**ï¼š
- æ¯ä¸ª API å¯†é’¥æœ€å¤š 100 ä¸ªå¹¶å‘æµå¼ä¼ è¾“è¿æ¥
- 5 åˆ†é’Ÿæ— æ´»åŠ¨è¶…æ—¶ï¼ˆè‡ªåŠ¨å…³é—­è¿æ¥ï¼‰
- æ¯ä¸ªè¿æ¥ 1MB ç¼“å†²åŒºå¤§å°é™åˆ¶
- è€ƒè™‘åœ¨å•ä¸ª WebSocket ä¸Šå¤šè·¯å¤ç”¨å¤šä¸ªå·¥ä½œæµ
</Warning>
