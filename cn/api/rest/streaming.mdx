---
title: "流式端点"
description: "通过 SSE 和 WebSocket 实时事件流传输"
---

## 概述

Shannon 通过 Server-Sent Events (SSE) 和 WebSocket 协议提供实时事件流传输。使用流式传输来监控任务执行、显示进度并在生成时接收结果。

## 端点

| 方法 | 端点 | 协议 | 描述 |
|-----|------|------|------|
| `GET` | `/api/v1/tasks/{id}/stream` | SSE | 流式传输特定任务的事件 |
| `GET` | `/api/v1/stream/sse` | SSE | Server-Sent Events 端点 |
| `GET` | `/api/v1/stream/ws` | WebSocket | WebSocket 流式传输端点 |
| `GET` | `/api/v1/tasks/{id}/events` | HTTP | 获取历史事件（分页） |

## Server-Sent Events (SSE)

### GET /api/v1/stream/sse

使用 Server-Sent Events 进行实时事件流传输。

#### 身份验证

**必需**：是

```
X-API-Key: sk_test_123456
```

#### 查询参数

| 参数 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `workflow_id` | string | 是 | 任务/工作流标识符 |
| `types` | string | 否 | 逗号分隔的事件类型以筛选 |
| `last_event_id` | string | 否 | 从特定事件 ID 恢复 |

#### 事件格式

每个事件遵循 SSE 规范：

```
id: <event_id>
event: <event_type>
data: <json_payload>

```

#### 示例请求

```bash
curl -N "http://localhost:8080/api/v1/stream/sse?workflow_id=task_abc123" \\
  -H "X-API-Key: sk_test_123456"
```

#### 示例响应

```
id: 1
event: WORKFLOW_STARTED
data: {"workflow_id":"task_abc123","timestamp":"2025-10-22T10:30:00Z","message":"工作流已启动"}

id: 2
event: AGENT_THINKING
data: {"workflow_id":"task_abc123","agent_id":"agent_1","message":"分析查询...","timestamp":"2025-10-22T10:30:01Z"}

id: 3
event: TOOL_INVOKED
data: {"workflow_id":"task_abc123","tool":"web_search","params":{"query":"Python 编程"},"timestamp":"2025-10-22T10:30:02Z"}

id: 4
event: TOOL_RESULT
data: {"workflow_id":"task_abc123","tool":"web_search","result":"...","timestamp":"2025-10-22T10:30:05Z"}

id: 5
event: AGENT_COMPLETED
data: {"workflow_id":"task_abc123","agent_id":"agent_1","result":"Python 是一种高级编程语言...","timestamp":"2025-10-22T10:30:06Z"}

id: 6
event: TASK_COMPLETED
data: {"workflow_id":"task_abc123","status":"COMPLETED","result":"...","timestamp":"2025-10-22T10:30:07Z"}
```

### GET /api/v1/tasks/{id}/stream

便捷端点，重定向到 `/api/v1/stream/sse`，并设置 workflow_id。

```bash
# 此端点
curl -N "http://localhost:8080/api/v1/tasks/task_abc123/stream" \\
  -H "X-API-Key: sk_test_123456"

# 重定向到（307 临时重定向）
curl -N "http://localhost:8080/api/v1/stream/sse?workflow_id=task_abc123" \\
  -H "X-API-Key: sk_test_123456"
```

## WebSocket

### GET /api/v1/stream/ws

通过 WebSocket 进行双向流式传输。

#### 身份验证

网关通过仅使用标头（`X-API-Key` 或 `Authorization`）来对 WebSocket 连接进行身份验证。浏览器在 WebSocket 握手期间无法设置自定义标头。对于浏览器使用：

- 以 `GATEWAY_SKIP_AUTH=1` 本地运行，或
- 使用反向代理在转发到网关之前注入标头。

服务器环境中基于标头的示例：

Node (ws)：
```js
import WebSocket from 'ws';

const ws = new WebSocket('ws://localhost:8080/api/v1/stream/ws', {
  headers: { 'X-API-Key': 'sk_test_123456' },
});

ws.on('open', () => {
  ws.send(JSON.stringify({ type: 'subscribe', workflow_id: 'task_abc123' }));
});

ws.on('message', (msg) => {
  const data = JSON.parse(msg.toString());
  console.log('事件：', data.type, data.message);
});

ws.on('error', (err) => console.error('WebSocket 错误：', err));
```

Python (websockets)：
```python
import asyncio, json, websockets

async def main():
    async with websockets.connect(
        'ws://localhost:8080/api/v1/stream/ws',
        extra_headers={'X-API-Key': 'sk_test_123456'},
    ) as ws:
        await ws.send(json.dumps({'type': 'subscribe', 'workflow_id': 'task_abc123'}))
        async for message in ws:
            data = json.loads(message)
            print('事件：', data.get('type'), data.get('message'))

asyncio.run(main())
```

<Note>
不支持通过查询字符串传递 API 密钥或通过网关的连接后"auth"消息。
</Note>

#### 消息类型

**客户端 → 服务器**：

```json
// 订阅工作流
{
  "type": "subscribe",
  "workflow_id": "task_abc123",
  "types": ["AGENT_THINKING", "TOOL_INVOKED"]
}

// 取消订阅
{
  "type": "unsubscribe",
  "workflow_id": "task_abc123"
}

// Ping（保活）
{
  "type": "ping"
}
```

**服务器 → 客户端**：

```json
// 事件
{
  "type": "AGENT_THINKING",
  "workflow_id": "task_abc123",
  "message": "分析查询...",
  "timestamp": "2025-10-22T10:30:00Z"
}

// Pong（保活响应）
{
  "type": "pong"
}
```

## 事件类型

### 核心事件

| 事件类型 | 描述 | 何时触发 |
|---------|------|---------|
| `WORKFLOW_STARTED` | 工作流执行开始 | 任务开始 |
| `WORKFLOW_COMPLETED` | 工作流成功完成 | 任务结束（成功） |
| `WORKFLOW_FAILED` | 工作流失败并出错 | 任务结束（失败） |
| `TASK_COMPLETED` | 任务结果可用 | 最终结果就绪 |

### 代理事件

| 事件类型 | 描述 | 载荷字段 |
|---------|------|---------|
| `AGENT_THINKING` | 代理推理/规划 | `agent_id`、`message` |
| `AGENT_PLANNING` | 代理创建执行计划 | `agent_id`、`plan` |
| `AGENT_COMPLETED` | 代理完成执行 | `agent_id`、`result` |

### 工具事件

| 事件类型 | 描述 | 载荷字段 |
|---------|------|---------|
| `TOOL_INVOKED` | 工具执行已启动 | `tool`、`params` |
| `TOOL_RESULT` | 工具执行已完成 | `tool`、`result` |
| `TOOL_ERROR` | 工具执行失败 | `tool`、`error` |

### 进度事件

| 事件类型 | 描述 | 载荷字段 |
|---------|------|---------|
| `PARTIAL_OUTPUT` | 流式 LLM 输出 | `text`、`is_final` |
| `PROGRESS_UPDATE` | 进度百分比 | `progress`、`message` |

### 错误事件

| 事件类型 | 描述 | 载荷字段 |
|---------|------|---------|
| `ERROR` | 发生一般错误 | `error`、`severity` |
| `TIMEOUT` | 任务超出超时 | `timeout_seconds` |

## 代码示例

### Python with httpx (SSE)

```python
import httpx
import json

def stream_task_events(task_id: str, api_key: str):
    """使用 SSE 流式传输任务事件。"""
    url = f"http://localhost:8080/api/v1/stream/sse?workflow_id={task_id}"

    with httpx.stream(
        "GET",
        url,
        headers={"X-API-Key": api_key},
        timeout=None  # 无流式传输超时
    ) as response:
        for line in response.iter_lines():
            if line.startswith("data:"):
                data = json.loads(line[5:])  # 移除"data:"前缀
                yield data

# 用法
for event in stream_task_events("task_abc123", "sk_test_123456"):
    print(f"[{event.get('type')}] {event.get('message', '')}")

    if event.get('type') == 'TASK_COMPLETED':
        print("最终结果：", event.get('result'))
        break
```

### Python - 流式传输带事件筛选

```python
def stream_filtered_events(task_id: str, api_key: str, event_types: list):
    """仅流式传输特定事件类型。"""
    types_param = ",".join(event_types)
    url = f"http://localhost:8080/api/v1/stream/sse?workflow_id={task_id}&types={types_param}"

    with httpx.stream("GET", url, headers={"X-API-Key": api_key}) as response:
        for line in response.iter_lines():
            if line.startswith("data:"):
                yield json.loads(line[5:])

# 仅接收代理思考和工具事件
for event in stream_filtered_events(
    "task_abc123",
    "sk_test_123456",
    ["AGENT_THINKING", "TOOL_INVOKED", "TOOL_RESULT"]
):
    print(f"{event['type']}：{event.get('message', event.get('tool'))}")
```

### JavaScript/Node.js (SSE)

```javascript
const EventSource = require('eventsource');

function streamTaskEvents(taskId, apiKey) {
  const url = `http://localhost:8080/api/v1/stream/sse?workflow_id=${taskId}`;

  const eventSource = new EventSource(url, {
    headers: {
      'X-API-Key': apiKey
    }
  });

  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log(`[${data.type}] ${data.message || ''}`);

    if (data.type === 'TASK_COMPLETED') {
      console.log('最终结果：', data.result);
      eventSource.close();
    }
  };

  eventSource.onerror = (error) => {
    console.error('SSE 错误：', error);
    eventSource.close();
  };

  return eventSource;
}

// 用法
const stream = streamTaskEvents('task_abc123', 'sk_test_123456');

// 手动关闭
setTimeout(() => stream.close(), 60000);
```

### JavaScript/Node.js - WebSocket (ws)

```javascript
import WebSocket from 'ws';

function connectWebSocket(taskId, apiKey) {
  const ws = new WebSocket(
    `ws://localhost:8080/api/v1/stream/ws?workflow_id=${taskId}`,
    { headers: { 'X-API-Key': apiKey } }
  );

  ws.on('open', () => console.log('✓ 已连接'));

  ws.on('message', (msg) => {
    const data = JSON.parse(msg.toString());
    switch (data.type) {
      case 'AGENT_THINKING':
        console.log(`💭 ${data.message}`);
        break;
      case 'TOOL_INVOKED':
        console.log(`🔧 工具：${data.tool}`);
        break;
      case 'TOOL_RESULT':
        console.log(`✓ 结果：${data.result}`);
        break;
      case 'TASK_COMPLETED':
        console.log(`✓ 完成：${data.result}`);
        ws.close();
        break;
      default:
        console.log(`[${data.type}] ${data.message || ''}`);
    }
  });

  ws.on('error', (err) => console.error('❌ 错误：', err));
  ws.on('close', () => console.log('连接已关闭'));

  return ws;
}

const ws = connectWebSocket('task_abc123', 'sk_test_123456');
```

### Go (SSE)

```go
package main

import (
    "bufio"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
)

type Event struct {
    Type      string                 `json:"type"`
    WorkflowID string                `json:"workflow_id"`
    Message   string                 `json:"message,omitempty"`
    Data      map[string]interface{} `json:",inline"`
}

func streamEvents(taskID, apiKey string) error {
    url := fmt.Sprintf(
        "http://localhost:8080/api/v1/stream/sse?workflow_id=%s",
        taskID,
    )

    req, _ := http.NewRequest("GET", url, nil)
    req.Header.Set("X-API-Key", apiKey)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    scanner := bufio.NewScanner(resp.Body)

    for scanner.Scan() {
        line := scanner.Text()

        if strings.HasPrefix(line, "data:") {
            data := strings.TrimPrefix(line, "data:")

            var event Event
            json.Unmarshal([]byte(data), &event)

            fmt.Printf("[%s] %s\n", event.Type, event.Message)

            if event.Type == "TASK_COMPLETED" {
                fmt.Println("✓ 任务完成")
                break
            }
        }
    }

    return scanner.Err()
}

func main() {
    err := streamEvents("task_abc123", "sk_test_123456")
    if err != nil {
        fmt.Println("错误：", err)
    }
}
```

### Bash/curl (SSE)

```bash
#!/bin/bash

API_KEY="sk_test_123456"
TASK_ID="$1"

curl -N "http://localhost:8080/api/v1/stream/sse?workflow_id=$TASK_ID" \\
  -H "X-API-Key: $API_KEY" \\
  | while IFS= read -r line; do
    if [[ $line == data:* ]]; then
      # 从"data：{...}"提取 JSON
      JSON="${line#data:}"

      # 解析并显示
      TYPE=$(echo "$JSON" | jq -r '.type')
      MESSAGE=$(echo "$JSON" | jq -r '.message // ""')

      echo "[$(date +%T)] $TYPE：$MESSAGE"

      # 完成时退出
      if [[ "$TYPE" == "TASK_COMPLETED" ]]; then
        echo ""
        echo "$JSON" | jq -r '.result'
        break
      fi
    fi
  done
```

## 用例

### 1. 实时进度显示

```python
def display_progress(task_id: str, api_key: str):
    """向用户显示实时进度。"""
    print(f"任务 {task_id} 启动...")

    for event in stream_task_events(task_id, api_key):
        event_type = event.get('type')

        if event_type == 'AGENT_THINKING':
            print(f"💭 {event['message']}")
        elif event_type == 'TOOL_INVOKED':
            print(f"🔧 使用工具：{event['tool']}")
        elif event_type == 'TOOL_RESULT':
            print(f"✓ 工具已完成")
        elif event_type == 'PARTIAL_OUTPUT':
            print(event['text'], end='', flush=True)
        elif event_type == 'TASK_COMPLETED':
            print(f"\n\n✓ 完成！")
            return event['result']
```

### 2. 将所有事件记录到文件

```python
import json
from datetime import datetime

def log_events_to_file(task_id: str, api_key: str, log_file: str):
    """将所有事件记录到 JSON Lines 文件。"""
    with open(log_file, 'a') as f:
        for event in stream_task_events(task_id, api_key):
            # 添加时间戳
            event['logged_at'] = datetime.now().isoformat()

            # 以 JSON Lines 格式写入
            f.write(json.dumps(event) + '\n')
            f.flush()

            if event.get('type') == 'TASK_COMPLETED':
                break

log_events_to_file("task_abc123", "sk_test_123456", "task_events.jsonl")
```

### 3. 收集工具使用指标

```python
def collect_tool_metrics(task_id: str, api_key: str):
    """收集有关工具使用的指标。"""
    metrics = {
        "tools_invoked": 0,
        "tools_succeeded": 0,
        "tools_failed": 0,
        "tool_list": []
    }

    for event in stream_task_events(task_id, api_key):
        if event.get('type') == 'TOOL_INVOKED':
            metrics['tools_invoked'] += 1
            metrics['tool_list'].append(event['tool'])
        elif event.get('type') == 'TOOL_RESULT':
            metrics['tools_succeeded'] += 1
        elif event.get('type') == 'TOOL_ERROR':
            metrics['tools_failed'] += 1
        elif event.get('type') == 'TASK_COMPLETED':
            break

    return metrics

metrics = collect_tool_metrics("task_abc123", "sk_test_123456")
print(f"使用的工具：{metrics['tool_list']}")
print(f"成功率：{metrics['tools_succeeded']}/{metrics['tools_invoked']}")
```

### 4. React UI 集成

```javascript
import { useState, useEffect } from 'react';

function TaskMonitor({ taskId, apiKey }) {
  const [events, setEvents] = useState([]);
  const [status, setStatus] = useState('connecting');

  useEffect(() => {
    const eventSource = new EventSource(
      `http://localhost:8080/api/v1/stream/sse?workflow_id=${taskId}`,
      { headers: { 'X-API-Key': apiKey } }
    );

    eventSource.onopen = () => setStatus('connected');

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setEvents(prev => [...prev, data]);

      if (data.type === 'TASK_COMPLETED') {
        setStatus('completed');
        eventSource.close();
      }
    };

    eventSource.onerror = () => {
      setStatus('error');
      eventSource.close();
    };

    return () => eventSource.close();
  }, [taskId, apiKey]);

  return (
    <div>
      <h3>状态：{status}</h3>
      <ul>
        {events.map((event, i) => (
          <li key={i}>
            <strong>{event.type}</strong>：{event.message || event.tool}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## 最佳实践

### 1. 处理连接错误

```python
import time

def stream_with_retry(task_id: str, api_key: str, max_retries: int = 3):
    """在连接失败时进行自动重试的流式传输。"""
    for attempt in range(max_retries):
        try:
            for event in stream_task_events(task_id, api_key):
                yield event

                if event.get('type') == 'TASK_COMPLETED':
                    return
        except Exception as e:
            if attempt < max_retries - 1:
                print(f"连接失败，{2 ** attempt}s 后重试...")
                time.sleep(2 ** attempt)
            else:
                raise
```

### 2. 实施超时

```python
import signal

def stream_with_timeout(task_id: str, api_key: str, timeout: int = 300):
    """具有超时的流式传输。"""
    def timeout_handler(signum, frame):
        raise TimeoutError("流式传输超时")

    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)

    try:
        for event in stream_task_events(task_id, api_key):
            yield event
            if event.get('type') == 'TASK_COMPLETED':
                break
    finally:
        signal.alarm(0)  # 取消闹钟
```

### 3. 客户端过滤事件

```python
def stream_specific_events(task_id: str, api_key: str, event_types: set):
    """客户端过滤事件。"""
    for event in stream_task_events(task_id, api_key):
        if event.get('type') in event_types:
            yield event

        if event.get('type') == 'TASK_COMPLETED':
            yield event
            break

# 仅接收代理和工具事件
for event in stream_specific_events(
    "task_abc123",
    "sk_test_123456",
    {"AGENT_THINKING", "TOOL_INVOKED", "TOOL_RESULT"}
):
    print(event)
```

### 4. 从最后一个事件恢复

```python
def stream_with_resume(task_id: str, api_key: str, last_event_id: str = None):
    """从特定事件恢复流式传输。"""
    url = f"http://localhost:8080/api/v1/stream/sse?workflow_id={task_id}"

    if last_event_id:
        url += f"&last_event_id={last_event_id}"

    # 流式传输事件...
```

## 比较：SSE vs WebSocket vs 轮询

| 功能 | SSE | WebSocket | 轮询 |
|-----|-----|-----------|-----|
| **方向** | 服务器 → 客户端 | 双向 | 客户端 → 服务器 |
| **协议** | HTTP | WebSocket | HTTP |
| **自动重连** | 是（浏览器） | 否（手动） | N/A |
| **开销** | 低 | 非常低 | 高 |
| **简洁性** | 高 | 中 | 高 |
| **使用场景** | 实时更新 | 交互式应用 | 简单状态 |
| **Shannon 支持** | ✅ 推荐 | ✅ 可用 | ⚠️ 不理想 |

### 何时使用每个

- **SSE**：大多数用例、实时监控、进度显示
- **WebSocket**：交互式应用、需要双向通信
- **轮询**（GET /api/v1/tasks/{id}）：传统系统、无流式传输支持

## 相关端点

<CardGroup cols={2}>
  <Card title="提交任务" icon="paper-plane" href="/cn/api/rest/submit-task">
    POST /api/v1/tasks
  </Card>
  <Card title="获取状态" icon="circle-info" href="/cn/api/rest/get-status">
    GET /api/v1/tasks/{id}
  </Card>
  <Card title="Python SDK" icon="python" href="/cn/sdk/python/quickstart">
    使用 client.stream()
  </Card>
</CardGroup>

## 注意

<Tip>
**事件保留**：事件存储在 Redis 中 24 小时。如果连接断开，使用 `last_event_id` 恢复流式传输。
</Tip>

<Warning>
**连接限制**：每个 API 密钥最多 100 个并发流式传输连接。考虑在单个 WebSocket 上多路复用多个工作流。
</Warning>
