---
title: "REST API 概览"
description: "Shannon Gateway 的完整 REST API 参考"
---

## 基础 URL

```
http://localhost:8080
```

对于生产环境部署，请将 `localhost:8080` 替换为您的网关 URL。

## API 端点

Shannon 提供了 11 个 REST API 端点，分为三类：

### 任务管理

| 方法 | 端点 | 描述 | 需要认证 |
|--------|----------|-------------|---------------|
| `POST` | `/api/v1/tasks` | 提交新任务 | 是 |
| `GET` | `/api/v1/tasks` | 列出任务（支持过滤） | 是 |
| `GET` | `/api/v1/tasks/{id}` | 获取任务状态和结果 | 是 |
| `GET` | `/api/v1/tasks/{id}/events` | 获取任务事件历史 | 是 |
| `GET` | `/api/v1/tasks/{id}/timeline` | 获取任务执行时间线 | 是 |

### 流式传输

| 方法 | 端点 | 描述 | 需要认证 |
|--------|----------|-------------|---------------|
| `GET` | `/api/v1/tasks/{id}/stream` | 流式传输任务事件 (SSE) | 是 |
| `GET` | `/api/v1/stream/sse` | Server-Sent Events 端点 | 是 |
| `GET` | `/api/v1/stream/ws` | WebSocket 流式传输端点 | 是 |

### 健康检查与可观测性

| 方法 | 端点 | 描述 | 需要认证 |
|--------|----------|-------------|---------------|
| `GET` | `/health` | 健康检查探针 | 否 |
| `GET` | `/readiness` | 就绪检查探针 | 否 |
| `GET` | `/openapi.json` | OpenAPI 3.0 规范 | 否 |

## 身份认证

所有任务和流式传输端点都需要通过 API 密钥进行身份认证。

### API 密钥请求头

```bash
curl -H "X-API-Key: sk_test_123456" \
  http://localhost:8080/api/v1/tasks
```

### 禁用认证（仅限开发环境）

设置环境变量：

```bash
GATEWAY_SKIP_AUTH=1
```

**警告**：切勿在生产环境中禁用身份认证。

## 通用请求头

### 请求头

| 请求头 | 必需 | 描述 | 示例 |
|--------|----------|-------------|---------|
| `X-API-Key` | 是* | 认证密钥 | `sk_test_123456` |
| `Content-Type` | 是 (POST) | 请求体格式 | `application/json` |
| `Idempotency-Key` | 否 | 防止重复提交 | `550e8400-e29b-41d4-a716-446655440000` |
| `traceparent` | 否 | W3C 追踪上下文 | `00-4bf92f...` |

*如果设置了 `GATEWAY_SKIP_AUTH=1` 则不需要

### 响应头

| 响应头 | 描述 | 示例 |
|--------|-------------|---------|
| `X-Workflow-ID` | Temporal 工作流标识符 | `task_abc123_workflow` |
| `X-Session-ID` | 会话标识符 | `user-123-session` |
| `Content-Type` | 响应格式 | `application/json` |

## 速率限制

速率限制按 API 密钥执行，存储在 Redis 中。

### 速率限制响应头

```bash
X-RateLimit-Limit: 100          # 每个时间窗口的请求数
X-RateLimit-Remaining: 95       # 剩余请求数
X-RateLimit-Reset: 1609459200   # Unix 时间戳
```

### 速率限制错误

**状态码**：`429 Too Many Requests`

```json
{
  "error": "Rate limit exceeded",
  "retry_after": 60
}
```

**默认限制**：
- **标准**：每个 API 密钥 100 请求/分钟
- **突发**：20 请求/秒

通过环境变量配置：
```bash
RATE_LIMIT_RPM=100
RATE_LIMIT_BURST=20
```

## 幂等性

POST 请求支持幂等性，以防止重复提交任务。

### 工作原理

1. 生成唯一的 `Idempotency-Key`（推荐使用 UUIDv4）
2. 在请求头中包含该密钥
3. Shannon 缓存响应 24 小时
4. 重复请求返回缓存的响应

### 示例

```bash
# 第一次请求 - 创建任务
curl -X POST http://localhost:8080/api/v1/tasks \
  -H "X-API-Key: sk_test_123456" \
  -H "Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000" \
  -H "Content-Type: application/json" \
  -d '{"query": "Analyze sales data"}'

# 响应: 200 OK
{
  "task_id": "task_abc123",
  "status": "TASK_STATUS_QUEUED"
}

# 重复请求（相同的 Idempotency-Key）- 返回缓存结果
curl -X POST http://localhost:8080/api/v1/tasks \
  -H "X-API-Key: sk_test_123456" \
  -H "Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000" \
  -H "Content-Type: application/json" \
  -d '{"query": "Different query"}'

# 响应: 200 OK (相同的 task_id，忽略新查询)
{
  "task_id": "task_abc123",
  "status": "TASK_STATUS_QUEUED"
}
```

**缓存持续时间**：24 小时（Redis TTL）

## 错误处理

### 标准错误响应

```json
{
  "error": "Error message describing what went wrong"
}
```

### HTTP 状态码

| 状态码 | 含义 | 常见原因 |
|------|---------|---------------|
| `200` | 成功 | 请求成功完成 |
| `400` | 错误请求 | 无效的 JSON，缺少必需字段 |
| `401` | 未授权 | 缺少或无效的 API 密钥 |
| `404` | 未找到 | 任务 ID 不存在 |
| `429` | 请求过多 | 超出速率限制 |
| `500` | 内部服务器错误 | 服务器错误，请检查日志 |
| `502` | 网关错误 | 上游服务不可用 |
| `503` | 服务不可用 | 系统过载或维护中 |

### 错误示例

**400 错误请求**：
```json
{
  "error": "Query is required"
}
```

**401 未授权**：
```json
{
  "error": "Unauthorized"
}
```

**404 未找到**：
```json
{
  "error": "Task not found"
}
```

**429 速率限制**：
```json
{
  "error": "Rate limit exceeded",
  "retry_after": 60
}
```

**500 内部服务器错误**：
```json
{
  "error": "Failed to submit task: database connection failed"
}
```

## 分布式追踪

Shannon 支持 W3C 追踪上下文进行分布式追踪。

### 追踪上下文请求头

```bash
curl -H "traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01" \
  http://localhost:8080/api/v1/tasks
```

### 格式

```
traceparent: {version}-{trace-id}-{parent-id}-{trace-flags}
```

- **version**：`00`（当前版本）
- **trace-id**：32 个十六进制字符（16 字节）
- **parent-id**：16 个十六进制字符（8 字节）
- **trace-flags**：2 个十六进制字符（采样标志）

追踪传播经过：
1. Gateway HTTP 处理器
2. 到 Orchestrator 的 gRPC 调用
3. Agent Core 执行
4. LLM Service 请求
5. Temporal 工作流

## CORS 配置

CORS 在开发环境中启用，采用宽松设置。

### 设置的响应头

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization, X-API-Key, Idempotency-Key, traceparent, tracestate
Access-Control-Max-Age: 3600
```

**生产环境**：配置 `Access-Control-Allow-Origin` 为特定域名。

## 超时设置

### 请求超时

| 操作 | 超时时间 |
|-----------|---------|
| 读取超时 | 30 秒 |
| 写入超时 | 30 秒 |
| 空闲超时 | 60 秒 |

### 任务执行超时

任务超时在平台级别配置：

```bash
WORKFLOW_TIMEOUT_SECONDS=600  # 默认 10 分钟
```

长时间运行的任务可能会超时。使用流式传输监控进度。

## 最佳实践

### 1. 使用幂等性密钥

始终为任务提交包含 `Idempotency-Key`：

```python
import uuid
import httpx

idempotency_key = str(uuid.uuid4())

response = httpx.post(
    "http://localhost:8080/api/v1/tasks",
    headers={
        "X-API-Key": "sk_test_123456",
        "Idempotency-Key": idempotency_key
    },
    json={"query": "Analyze data"}
)
```

### 2. 处理速率限制

实现指数退避：

```python
import time
import httpx

def submit_with_retry(query, max_retries=3):
    for attempt in range(max_retries):
        response = httpx.post(
            "http://localhost:8080/api/v1/tasks",
            headers={"X-API-Key": "sk_test_123456"},
            json={"query": query}
        )

        if response.status_code == 429:
            retry_after = int(response.headers.get("Retry-After", 60))
            time.sleep(retry_after)
            continue

        return response

    raise Exception("Max retries exceeded")
```

### 3. 对长任务使用流式传输

不要轮询状态 - 使用 SSE 流式传输：

```python
import httpx

with httpx.stream(
    "GET",
    f"http://localhost:8080/api/v1/tasks/{task_id}/stream",
    headers={"X-API-Key": "sk_test_123456"}
) as response:
    for line in response.iter_lines():
        if line.startswith("data:"):
            event = json.loads(line[5:])
            print(event["type"], event["message"])
```

### 4. 启用追踪

传递追踪上下文以便可观测性：

```python
import uuid

trace_id = uuid.uuid4().hex + uuid.uuid4().hex  # 32 个字符
parent_id = uuid.uuid4().hex[:16]               # 16 个字符
traceparent = f"00-{trace_id}-{parent_id}-01"

response = httpx.post(
    "http://localhost:8080/api/v1/tasks",
    headers={
        "X-API-Key": "sk_test_123456",
        "traceparent": traceparent
    },
    json={"query": "Analyze data"}
)
```

### 5. 检查响应头

提取工作流和会话 ID 以便追踪：

```python
response = httpx.post(
    "http://localhost:8080/api/v1/tasks",
    headers={"X-API-Key": "sk_test_123456"},
    json={"query": "Analyze data"}
)

workflow_id = response.headers.get("X-Workflow-ID")
session_id = response.headers.get("X-Session-ID")

print(f"Track at: http://localhost:8088/workflows/{workflow_id}")
```

## 快速开始示例

### 提交和监控任务

```bash
#!/bin/bash

API_KEY="sk_test_123456"
BASE_URL="http://localhost:8080"

# 1. 提交任务
RESPONSE=$(curl -s -X POST "$BASE_URL/api/v1/tasks" \
  -H "X-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"query": "What is the capital of France?"}')

TASK_ID=$(echo $RESPONSE | jq -r '.task_id')
echo "Task ID: $TASK_ID"

# 2. 检查状态
curl -s "$BASE_URL/api/v1/tasks/$TASK_ID" \
  -H "X-API-Key: $API_KEY" | jq

# 3. 获取事件
curl -s "$BASE_URL/api/v1/tasks/$TASK_ID/events" \
  -H "X-API-Key: $API_KEY" | jq

# 4. 流式事件 (SSE)
curl -N "$BASE_URL/api/v1/tasks/$TASK_ID/stream" \
  -H "X-API-Key: $API_KEY"
```

## 下一步

<CardGroup cols={2}>
  <Card title="提交任务" icon="paper-plane" href="/cn/api/rest/submit-task">
    POST /api/v1/tasks 参考
  </Card>
  <Card title="列出任务" icon="list" href="/cn/api/rest/list-tasks">
    GET /api/v1/tasks 参考
  </Card>
  <Card title="获取状态" icon="circle-info" href="/cn/api/rest/get-status">
    GET /api/v1/tasks/{id} 参考
  </Card>
  <Card title="流式传输" icon="stream" href="/cn/api/rest/streaming">
    实时事件流式传输
  </Card>
</CardGroup>

